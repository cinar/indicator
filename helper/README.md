<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# helper

```go
import "github.com/cinar/indicator/v2/helper"
```

Package helper contains the helper functions.

This package belongs to the Indicator project. Indicator is a Golang module that supplies a variety of technical indicators, strategies, and a backtesting framework for analysis.

### License

```
Copyright (c) 2021-2024 Onur Cinar.
The source code is provided under GNU AGPLv3 License.
https://github.com/cinar/indicator
```

### Disclaimer

The information provided on this project is strictly for informational purposes and is not to be construed as advice or solicitation to buy or sell any security.

## Index

- [Constants](<#constants>)
- [func Abs\[T Number\]\(c \<\-chan T\) \<\-chan T](<#Abs>)
- [func Add\[T Number\]\(ac, bc \<\-chan T\) \<\-chan T](<#Add>)
- [func AppendOrWriteToCsvFile\[T any\]\(fileName string, hasHeader bool, rows \<\-chan \*T\) error](<#AppendOrWriteToCsvFile>)
- [func Apply\[T Number\]\(c \<\-chan T, f func\(T\) T\) \<\-chan T](<#Apply>)
- [func Buffered\[T any\]\(c \<\-chan T, size int\) \<\-chan T](<#Buffered>)
- [func ChanToJSON\[T any\]\(c \<\-chan T, w io.Writer\) error](<#ChanToJSON>)
- [func ChanToSlice\[T any\]\(c \<\-chan T\) \[\]T](<#ChanToSlice>)
- [func Change\[T Number\]\(c \<\-chan T, before int\) \<\-chan T](<#Change>)
- [func ChangePercent\[T Number\]\(c \<\-chan T, before int\) \<\-chan T](<#ChangePercent>)
- [func ChangeRatio\[T Number\]\(c \<\-chan T, before int\) \<\-chan T](<#ChangeRatio>)
- [func CheckEquals\[T comparable\]\(inputs ...\<\-chan T\) error](<#CheckEquals>)
- [func CloseAndLogError\(closer io.Closer, message string\)](<#CloseAndLogError>)
- [func CloseAndLogErrorWithLogger\(closer io.Closer, message string, logger \*slog.Logger\)](<#CloseAndLogErrorWithLogger>)
- [func CommonPeriod\(periods ...int\) int](<#CommonPeriod>)
- [func Count\[T Number, O any\]\(from T, other \<\-chan O\) \<\-chan T](<#Count>)
- [func DaysBetween\(from, to time.Time\) int](<#DaysBetween>)
- [func DecrementBy\[T Number\]\(c \<\-chan T, d T\) \<\-chan T](<#DecrementBy>)
- [func Divide\[T Number\]\(ac, bc \<\-chan T\) \<\-chan T](<#Divide>)
- [func DivideBy\[T Number\]\(c \<\-chan T, d T\) \<\-chan T](<#DivideBy>)
- [func Drain\[T any\]\(c \<\-chan T\)](<#Drain>)
- [func Duplicate\[T any\]\(input \<\-chan T, count int\) \[\]\<\-chan T](<#Duplicate>)
- [func Echo\[T any\]\(input \<\-chan T, last, count int\) \<\-chan T](<#Echo>)
- [func Field\[T, S any\]\(c \<\-chan \*S, name string\) \(\<\-chan T, error\)](<#Field>)
- [func Filter\[T any\]\(c \<\-chan T, p func\(T\) bool\) \<\-chan T](<#Filter>)
- [func First\[T any\]\(c \<\-chan T, count int\) \<\-chan T](<#First>)
- [func Gcd\(values ...int\) int](<#Gcd>)
- [func Head\[T Number\]\(c \<\-chan T, count int\) \<\-chan T](<#Head>)
- [func IncrementBy\[T Number\]\(c \<\-chan T, i T\) \<\-chan T](<#IncrementBy>)
- [func JSONToChan\[T any\]\(r io.Reader\) \<\-chan T](<#JSONToChan>)
- [func JSONToChanWithLogger\[T any\]\(r io.Reader, logger \*slog.Logger\) \<\-chan T](<#JSONToChanWithLogger>)
- [func KeepNegatives\[T Number\]\(c \<\-chan T\) \<\-chan T](<#KeepNegatives>)
- [func KeepPositives\[T Number\]\(c \<\-chan T\) \<\-chan T](<#KeepPositives>)
- [func Last\[T any\]\(c \<\-chan T, count int\) \<\-chan T](<#Last>)
- [func Lcm\(values ...int\) int](<#Lcm>)
- [func Map\[F, T any\]\(c \<\-chan F, f func\(F\) T\) \<\-chan T](<#Map>)
- [func MapWithPrevious\[F, T any\]\(c \<\-chan F, f func\(T, F\) T, previous T\) \<\-chan T](<#MapWithPrevious>)
- [func Multiply\[T Number\]\(ac, bc \<\-chan T\) \<\-chan T](<#Multiply>)
- [func MultiplyBy\[T Number\]\(c \<\-chan T, m T\) \<\-chan T](<#MultiplyBy>)
- [func Operate\[A any, B any, R any\]\(ac \<\-chan A, bc \<\-chan B, o func\(A, B\) R\) \<\-chan R](<#Operate>)
- [func Operate3\[A any, B any, C any, R any\]\(ac \<\-chan A, bc \<\-chan B, cc \<\-chan C, o func\(A, B, C\) R\) \<\-chan R](<#Operate3>)
- [func Pipe\[T any\]\(f \<\-chan T, t chan\<\- T\)](<#Pipe>)
- [func Pow\[T Number\]\(c \<\-chan T, y T\) \<\-chan T](<#Pow>)
- [func ReadFromCsvFile\[T any\]\(fileName string, hasHeader bool\) \(\<\-chan \*T, error\)](<#ReadFromCsvFile>)
- [func RoundDigit\[T Number\]\(n T, d int\) T](<#RoundDigit>)
- [func RoundDigits\[T Number\]\(c \<\-chan T, d int\) \<\-chan T](<#RoundDigits>)
- [func Seq\[T Number\]\(from, to, increment T\) \<\-chan T](<#Seq>)
- [func Shift\[T any\]\(c \<\-chan T, count int, fill T\) \<\-chan T](<#Shift>)
- [func Sign\[T Number\]\(c \<\-chan T\) \<\-chan T](<#Sign>)
- [func Since\[T comparable, R Number\]\(c \<\-chan T\) \<\-chan R](<#Since>)
- [func Skip\[T any\]\(c \<\-chan T, count int\) \<\-chan T](<#Skip>)
- [func SliceToChan\[T any\]\(slice \[\]T\) \<\-chan T](<#SliceToChan>)
- [func Sqrt\[T Number\]\(c \<\-chan T\) \<\-chan T](<#Sqrt>)
- [func Subtract\[T Number\]\(ac, bc \<\-chan T\) \<\-chan T](<#Subtract>)
- [func SyncPeriod\[T any\]\(commonPeriod, period int, c \<\-chan T\) \<\-chan T](<#SyncPeriod>)
- [func Waitable\[T any\]\(wg \*sync.WaitGroup, c \<\-chan T\) \<\-chan T](<#Waitable>)
- [type Bst](<#Bst>)
  - [func NewBst\[T Number\]\(\) \*Bst\[T\]](<#NewBst>)
  - [func \(b \*Bst\[T\]\) Contains\(value T\) bool](<#Bst[T].Contains>)
  - [func \(b \*Bst\[T\]\) Insert\(value T\)](<#Bst[T].Insert>)
  - [func \(b \*Bst\[T\]\) Max\(\) T](<#Bst[T].Max>)
  - [func \(b \*Bst\[T\]\) Min\(\) T](<#Bst[T].Min>)
  - [func \(b \*Bst\[T\]\) Remove\(value T\) bool](<#Bst[T].Remove>)
- [type BstNode](<#BstNode>)
- [type Csv](<#Csv>)
  - [func NewCsv\[T any\]\(hasHeader bool\) \(\*Csv\[T\], error\)](<#NewCsv>)
  - [func \(c \*Csv\[T\]\) AppendToFile\(fileName string, rows \<\-chan \*T\) error](<#Csv[T].AppendToFile>)
  - [func \(c \*Csv\[T\]\) ReadFromFile\(fileName string\) \(\<\-chan \*T, error\)](<#Csv[T].ReadFromFile>)
  - [func \(c \*Csv\[T\]\) ReadFromReader\(reader io.Reader\) \<\-chan \*T](<#Csv[T].ReadFromReader>)
  - [func \(c \*Csv\[T\]\) WriteToFile\(fileName string, rows \<\-chan \*T\) error](<#Csv[T].WriteToFile>)
- [type Float](<#Float>)
- [type Integer](<#Integer>)
- [type Number](<#Number>)
- [type Report](<#Report>)
  - [func NewReport\(title string, date \<\-chan time.Time\) \*Report](<#NewReport>)
  - [func \(r \*Report\) AddChart\(\) int](<#Report.AddChart>)
  - [func \(r \*Report\) AddColumn\(column ReportColumn, charts ...int\)](<#Report.AddColumn>)
  - [func \(r \*Report\) WriteToFile\(fileName string\) error](<#Report.WriteToFile>)
  - [func \(r \*Report\) WriteToWriter\(writer io.Writer\) error](<#Report.WriteToWriter>)
- [type ReportColumn](<#ReportColumn>)
  - [func NewAnnotationReportColumn\(values \<\-chan string\) ReportColumn](<#NewAnnotationReportColumn>)
  - [func NewNumericReportColumn\[T Number\]\(name string, values \<\-chan T\) ReportColumn](<#NewNumericReportColumn>)
- [type Ring](<#Ring>)
  - [func NewRing\[T any\]\(size int\) \*Ring\[T\]](<#NewRing>)
  - [func \(r \*Ring\[T\]\) At\(index int\) T](<#Ring[T].At>)
  - [func \(r \*Ring\[T\]\) Get\(\) \(T, bool\)](<#Ring[T].Get>)
  - [func \(r \*Ring\[T\]\) IsEmpty\(\) bool](<#Ring[T].IsEmpty>)
  - [func \(r \*Ring\[T\]\) IsFull\(\) bool](<#Ring[T].IsFull>)
  - [func \(r \*Ring\[T\]\) Put\(t T\) T](<#Ring[T].Put>)


## Constants

<a name="CsvHeaderTag"></a>

```go
const (
    // CsvHeaderTag represents the parameter name for the column header.
    CsvHeaderTag = "header"

    // CsvFormatTag represents the parameter name for the column format.
    CsvFormatTag = "format"

    // DefaultDateTimeFormat denotes the default format of a date and time column.
    DefaultDateTimeFormat = "2006-01-02 15:04:05"
)
```

<a name="DefaultReportDateFormat"></a>

```go
const (
    // DefaultReportDateFormat is the default date format used in the report.
    DefaultReportDateFormat = "2006-01-02"
)
```

<a name="Abs"></a>
## func [Abs](<https://github.com/cinar/indicator/blob/master/helper/abs.go#L15>)

```go
func Abs[T Number](c <-chan T) <-chan T
```

Abs calculates the absolute value of each value in a channel of float64.

Example:

```
abs := helper.Abs(helper.SliceToChan([]int{-10, 20, -4, -5}))
fmt.Println(helper.ChanToSlice(abs)) // [10, 20, 4, 5]
```

<a name="Add"></a>
## func [Add](<https://github.com/cinar/indicator/blob/master/helper/add.go#L18>)

```go
func Add[T Number](ac, bc <-chan T) <-chan T
```

Add adds each pair of values from the two input channels of float64 and returns a new channel containing the sums.

Example:

```
ac := helper.SliceToChan([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10})
bc := helper.SliceToChan([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10})

actual := helper.ChanToSlice(helper.Add(ac, bc))

fmt.Println(actual) // [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
```

<a name="AppendOrWriteToCsvFile"></a>
## func [AppendOrWriteToCsvFile](<https://github.com/cinar/indicator/blob/master/helper/csv.go#L291>)

```go
func AppendOrWriteToCsvFile[T any](fileName string, hasHeader bool, rows <-chan *T) error
```

AppendOrWriteToCsvFile writes the provided rows of data to the specified file, appending to the existing file if it exists or creating a new one if it doesn't. In append mode, the function assumes that the existing file's column order matches the field order of the given row struct to ensure consistent data structure.

<a name="Apply"></a>
## func [Apply](<https://github.com/cinar/indicator/blob/master/helper/apply.go#L17>)

```go
func Apply[T Number](c <-chan T, f func(T) T) <-chan T
```

Apply applies the given transformation function to each element in the input channel and returns a new channel containing the transformed values. The transformation function takes a float64 value as input and returns a float64 value as output.

Example:

```
timesTwo := helper.Apply(c, func(n int) int {
	return n * 2
})
```

<a name="Buffered"></a>
## func [Buffered](<https://github.com/cinar/indicator/blob/master/helper/buffered.go#L12>)

```go
func Buffered[T any](c <-chan T, size int) <-chan T
```

Buffered takes a channel of any type and returns a new channel of the same type with a buffer of the specified size. This allows the original channel to continue sending data even if the receiving end is temporarily unavailable.

Example:

<a name="ChanToJSON"></a>
## func [ChanToJSON](<https://github.com/cinar/indicator/blob/master/helper/chan_to_json.go#L23>)

```go
func ChanToJSON[T any](c <-chan T, w io.Writer) error
```

ChanToJSON converts a channel of values into JSON format and writes it to the specified writer.

Example:

```
input := helper.SliceToChan([]int{2, 4, 6, 8})

var buffer bytes.Buffer
err := helper.ChanToJSON(input, &buffer)

fmt.Println(buffer.String())
// Output: [2,4,6,8,9]
```

<a name="ChanToSlice"></a>
## func [ChanToSlice](<https://github.com/cinar/indicator/blob/master/helper/chan_to_slice.go#L19>)

```go
func ChanToSlice[T any](c <-chan T) []T
```

ChanToSlice converts a channel of float64 to a slice of float64.

Example:

```
c := make(chan int, 4)
c <- 1
c <- 2
c < -3
c <- 4
close(c)

fmt.Println(helper.ChanToSlice(c)) // [1, 2, 3, 4]
```

<a name="Change"></a>
## func [Change](<https://github.com/cinar/indicator/blob/master/helper/change.go#L14>)

```go
func Change[T Number](c <-chan T, before int) <-chan T
```

Change calculates the difference between the current value and the value N before.

Example:

```
input := []int{1, 2, 5, 5, 8, 2, 1, 1, 3, 4}
output := helper.Change(helper.SliceToChan(input), 2)
fmt.Println(helper.ChanToSlice(output)) // [4, 3, 3, -3, -7, -1, 2, 3]
```

<a name="ChangePercent"></a>
## func [ChangePercent](<https://github.com/cinar/indicator/blob/master/helper/change_percent.go#L15>)

```go
func ChangePercent[T Number](c <-chan T, before int) <-chan T
```

ChangePercent calculates the percentage change between the current value and the value N positions before.

Example:

```
c := helper.ChanToSlice([]float64{1, 2, 5, 5, 8, 2, 1, 1, 3, 4})
actual := helper.ChangePercent(c, 2))
fmt.Println(helper.ChanToSlice(actual)) // [400, 150, 60, -60, -87.5, -50, 200, 300]
```

<a name="ChangeRatio"></a>
## func [ChangeRatio](<https://github.com/cinar/indicator/blob/master/helper/change_ratio.go#L15>)

```go
func ChangeRatio[T Number](c <-chan T, before int) <-chan T
```

ChangeRatio calculates the ratio change between the current value and the value N positions before.

Example:

```
c := helper.ChanToSlice([]float64{1, 2, 5, 5, 8, 2, 1, 1, 3, 4})
actual := helper.ChangeRatio(c, 2))
fmt.Println(helper.ChanToSlice(actual)) // [400, 150, 60, -60, -87.5, -50, 200, 300]
```

<a name="CheckEquals"></a>
## func [CheckEquals](<https://github.com/cinar/indicator/blob/master/helper/check.go#L14>)

```go
func CheckEquals[T comparable](inputs ...<-chan T) error
```

CheckEquals determines whether the two channels are equal.

<a name="CloseAndLogError"></a>
## func [CloseAndLogError](<https://github.com/cinar/indicator/blob/master/helper/closer.go#L13>)

```go
func CloseAndLogError(closer io.Closer, message string)
```

CloseAndLogError attempts to close the closer and logs any error.

<a name="CloseAndLogErrorWithLogger"></a>
## func [CloseAndLogErrorWithLogger](<https://github.com/cinar/indicator/blob/master/helper/closer.go#L18>)

```go
func CloseAndLogErrorWithLogger(closer io.Closer, message string, logger *slog.Logger)
```

CloseAndLogErrorWithLogger attempts to close the closer and logs any error to the given logger.

<a name="CommonPeriod"></a>
## func [CommonPeriod](<https://github.com/cinar/indicator/blob/master/helper/sync.go#L24>)

```go
func CommonPeriod(periods ...int) int
```

CommonPeriod calculates the smallest period at which all data channels can be synchronized

Example:

```
// Synchronize channels with periods 4, 2, and 3.
commonPeriod := helper.CommonPeriod(4, 2, 3) // commonPeriod = 4

// Synchronize the first channel
c1 := helper.Sync(commonPeriod, 4, c1)

// Synchronize the second channel
c2 := helper.Sync(commonPeriod, 2, c2)

// Synchronize the third channel
c3 := helper.Sync(commonPeriod, 3, c3)
```

<a name="Count"></a>
## func [Count](<https://github.com/cinar/indicator/blob/master/helper/count.go#L25>)

```go
func Count[T Number, O any](from T, other <-chan O) <-chan T
```

Count generates a sequence of numbers starting with a specified value, from, and incrementing by one until the given other channel continues to produce values.

Example:

```
other := make(chan int, 4)
other <- 1
other <- 1
other <- 1
other <- 1
close(other)

c := Count(0, other)

fmt.Println(<- s) // 1
fmt.Println(<- s) // 2
fmt.Println(<- s) // 3
fmt.Println(<- s) // 4
```

<a name="DaysBetween"></a>
## func [DaysBetween](<https://github.com/cinar/indicator/blob/master/helper/days_between.go#L13>)

```go
func DaysBetween(from, to time.Time) int
```

DaysBetween calculates the days between the given two times.

<a name="DecrementBy"></a>
## func [DecrementBy](<https://github.com/cinar/indicator/blob/master/helper/decrement_by.go#L16>)

```go
func DecrementBy[T Number](c <-chan T, d T) <-chan T
```

DecrementBy decrements each element in the input channel by the specified decrement value and returns a new channel containing the decremented values.

Example:

```
input := helper.SliceToChan([]int{1, 2, 3, 4})
substractOne := helper.DecrementBy(input, 1)
fmt.Println(helper.ChanToSlice(substractOne)) // [0, 1, 2, 3]
```

<a name="Divide"></a>
## func [Divide](<https://github.com/cinar/indicator/blob/master/helper/divide.go#L20>)

```go
func Divide[T Number](ac, bc <-chan T) <-chan T
```

Divide takes two channels of float64 and divides the values from the first channel with the values from the second one. It returns a new channel containing the results of the division.

Example:

```
ac := helper.SliceToChan([]int{2, 4, 6, 8, 10})
bc := helper.SliceToChan([]int{2, 1, 3, 2, 5})

division := helper.Divide(ac, bc)

fmt.Println(helper.ChanToSlice(division)) // [1, 4, 2, 4, 2]
```

<a name="DivideBy"></a>
## func [DivideBy](<https://github.com/cinar/indicator/blob/master/helper/divide_by.go#L15>)

```go
func DivideBy[T Number](c <-chan T, d T) <-chan T
```

DivideBy divides each element in the input channel of float64 values by the given divider and returns a new channel containing the divided values.

Example:

```
half := helper.DivideBy(helper.SliceToChan([]int{2, 4, 6, 8}), 2)
fmt.Println(helper.ChanToSlice(half)) // [1, 2, 3, 4]
```

<a name="Drain"></a>
## func [Drain](<https://github.com/cinar/indicator/blob/master/helper/drain.go#L8>)

```go
func Drain[T any](c <-chan T)
```

Drain drains the given channel. It blocks the caller.

<a name="Duplicate"></a>
## func [Duplicate](<https://github.com/cinar/indicator/blob/master/helper/duplicate.go#L17>)

```go
func Duplicate[T any](input <-chan T, count int) []<-chan T
```

Duplicate duplicates a given receive\-only channel by reading each value coming out of that channel and sending them on requested number of new output channels.

Example:

```
expected := helper.SliceToChan([]float64{-10, 20, -4, -5})
outputs := helper.Duplicates[float64](helper.SliceToChan(expected), 2)

fmt.Println(helper.ChanToSlice(outputs[0])) // [-10, 20, -4, -5]
fmt.Println(helper.ChanToSlice(outputs[1])) // [-10, 20, -4, -5]
```

<a name="Echo"></a>
## func [Echo](<https://github.com/cinar/indicator/blob/master/helper/echo.go#L14>)

```go
func Echo[T any](input <-chan T, last, count int) <-chan T
```

Echo takes a channel of numbers, repeats the specified count of numbers at the end by the specified count.

Example:

```
input := helper.SliceToChan([]int{2, 4, 6, 8})
output := helper.Echo(input, 2, 4))
fmt.Println(helper.ChanToSlice(output)) // [2, 4, 6, 8, 6, 8, 6, 8, 6, 8, 6, 8]
```

<a name="Field"></a>
## func [Field](<https://github.com/cinar/indicator/blob/master/helper/field.go#L14>)

```go
func Field[T, S any](c <-chan *S, name string) (<-chan T, error)
```

Field extracts a specific field from a channel of struct pointers and delivers it through a new channel.

<a name="Filter"></a>
## func [Filter](<https://github.com/cinar/indicator/blob/master/helper/filter.go#L17>)

```go
func Filter[T any](c <-chan T, p func(T) bool) <-chan T
```

Filter filters the items from the input channel based on the provided predicate function. The predicate function takes a float64 value as input and returns a boolean value indicating whether the value should be included in the output channel.

Example:

```
even := helper.Filter(c, func(n int) bool {
  return n%2 == 0
})
```

<a name="First"></a>
## func [First](<https://github.com/cinar/indicator/blob/master/helper/first.go#L8>)

```go
func First[T any](c <-chan T, count int) <-chan T
```

First takes a channel of values and returns a new channel containing the first N values.

<a name="Gcd"></a>
## func [Gcd](<https://github.com/cinar/indicator/blob/master/helper/gcd.go#L8>)

```go
func Gcd(values ...int) int
```

Gcd calculates the Greatest Common Divisor of the given numbers.

<a name="Head"></a>
## func [Head](<https://github.com/cinar/indicator/blob/master/helper/head.go#L16>)

```go
func Head[T Number](c <-chan T, count int) <-chan T
```

Head retrieves the specified number of elements from the given channel of float64 values and delivers them through a new channel.

Example:

```
c := helper.SliceToChan([]int{2, 4, 6, 8})
actual := helper.Head(c, 2)
fmt.Println(helper.ChanToSlice(actual)) // [2, 4]
```

<a name="IncrementBy"></a>
## func [IncrementBy](<https://github.com/cinar/indicator/blob/master/helper/increment_by.go#L16>)

```go
func IncrementBy[T Number](c <-chan T, i T) <-chan T
```

IncrementBy increments each element in the input channel by the specified increment value and returns a new channel containing the incremented values.

Example:

```
input := []int{1, 2, 3, 4}
actual := helper.IncrementBy(helper.SliceToChan(input), 1)
fmt.Println(helper.ChanToSlice(actual)) // [2, 3, 4, 5]
```

<a name="JSONToChan"></a>
## func [JSONToChan](<https://github.com/cinar/indicator/blob/master/helper/json_to_chan.go#L14>)

```go
func JSONToChan[T any](r io.Reader) <-chan T
```

JSONToChan reads values from the specified reader in JSON format into a channel of values.

<a name="JSONToChanWithLogger"></a>
## func [JSONToChanWithLogger](<https://github.com/cinar/indicator/blob/master/helper/json_to_chan.go#L19>)

```go
func JSONToChanWithLogger[T any](r io.Reader, logger *slog.Logger) <-chan T
```

JSONToChanWithLogger reads values from the specified reader in JSON format into a channel of values.

<a name="KeepNegatives"></a>
## func [KeepNegatives](<https://github.com/cinar/indicator/blob/master/helper/keep_negatives.go#L15>)

```go
func KeepNegatives[T Number](c <-chan T) <-chan T
```

KeepNegatives processes a stream of float64 values, retaining negative values unchanged and replacing positive values with zero.

Example:

```
c := helper.SliceToChan([]int{-10, 20, 4, -5})
negatives := helper.KeepPositives(c)
fmt.Println(helper.ChanToSlice(negatives)) // [-10, 0, 0, -5]
```

<a name="KeepPositives"></a>
## func [KeepPositives](<https://github.com/cinar/indicator/blob/master/helper/keep_positives.go#L15>)

```go
func KeepPositives[T Number](c <-chan T) <-chan T
```

KeepPositives processes a stream of float64 values, retaining positive values unchanged and replacing negative values with zero.

Example:

```
c := helper.SliceToChan([]int{-10, 20, 4, -5})
positives := helper.KeepPositives(c)
fmt.Println(helper.ChanToSlice(positives)) // [0, 20, 4, 0]
```

<a name="Last"></a>
## func [Last](<https://github.com/cinar/indicator/blob/master/helper/last.go#L8>)

```go
func Last[T any](c <-chan T, count int) <-chan T
```

Last takes a channel of values and returns a new channel containing the last N values.

<a name="Lcm"></a>
## func [Lcm](<https://github.com/cinar/indicator/blob/master/helper/lcm.go#L8>)

```go
func Lcm(values ...int) int
```

Lcm calculates the Least Common Multiple of the given numbers.

<a name="Map"></a>
## func [Map](<https://github.com/cinar/indicator/blob/master/helper/map.go#L17>)

```go
func Map[F, T any](c <-chan F, f func(F) T) <-chan T
```

Map applies the given transformation function to each element in the input channel and returns a new channel containing the transformed values. The transformation function takes a float64 value as input and returns a float64 value as output.

Example:

```
timesTwo := helper.Map(c, func(n int) int {
	return n * 2
})
```

<a name="MapWithPrevious"></a>
## func [MapWithPrevious](<https://github.com/cinar/indicator/blob/master/helper/map_with_previous.go#L17>)

```go
func MapWithPrevious[F, T any](c <-chan F, f func(T, F) T, previous T) <-chan T
```

MapWithPrevious applies a transformation function to each element in an input channel, creating a new channel with the transformed values. It maintains a "memory" of the previous result, allowing the transformation function to consider both the current element and the outcome of the previous transformation. This enables functions that rely on accumulated state or sequential dependencies between elements.

Example:

```
sum := helper.MapWithPrevious(c, func(p, c int) int {
	return p + c
}, 0)
```

<a name="Multiply"></a>
## func [Multiply](<https://github.com/cinar/indicator/blob/master/helper/multiply.go#L20>)

```go
func Multiply[T Number](ac, bc <-chan T) <-chan T
```

Multiply takes two channels of float64 and multiples the values from the first channel with the values from the second channel. It returns a new channel containing the results of the multiplication.

Example:

```
ac := helper.SliceToChan([]int{1, 4, 2, 4, 2})
bc := helper.SliceToChan([]int{2, 1, 3, 2, 5})

multiplication := helper.Multiply(ac, bc)

fmt.Println(helper.ChanToSlice(multiplication)) // [2, 4, 6, 8, 10]
```

<a name="MultiplyBy"></a>
## func [MultiplyBy](<https://github.com/cinar/indicator/blob/master/helper/multiply_by.go#L16>)

```go
func MultiplyBy[T Number](c <-chan T, m T) <-chan T
```

MultiplyBy multiplies each element in the input channel of float64 values by the given multiplier and returns a new channel containing the multiplied values.

Example:

```
c := helper.SliceToChan([]int{1, 2, 3, 4})
twoTimes := helper.MultiplyBy(c, 2)
fmt.Println(helper.ChanToSlice(twoTimes)) // [2, 4, 6, 8]
```

<a name="Operate"></a>
## func [Operate](<https://github.com/cinar/indicator/blob/master/helper/operate.go#L15>)

```go
func Operate[A any, B any, R any](ac <-chan A, bc <-chan B, o func(A, B) R) <-chan R
```

Operate applies the provided operate function to corresponding values from two numeric input channels and sends the resulting values to an output channel.

Example:

```
add := helper.Operate(ac, bc, func(a, b int) int {
  return a + b
})
```

<a name="Operate3"></a>
## func [Operate3](<https://github.com/cinar/indicator/blob/master/helper/operate3.go#L15>)

```go
func Operate3[A any, B any, C any, R any](ac <-chan A, bc <-chan B, cc <-chan C, o func(A, B, C) R) <-chan R
```

Operate3 applies the provided operate function to corresponding values from three numeric input channels and sends the resulting values to an output channel.

Example:

```
add := helper.Operate3(ac, bc, cc, func(a, b, c int) int {
  return a + b + c
})
```

<a name="Pipe"></a>
## func [Pipe](<https://github.com/cinar/indicator/blob/master/helper/pipe.go#L16>)

```go
func Pipe[T any](f <-chan T, t chan<- T)
```

Pipe function takes an input channel and an output channel and copies all elements from the input channel into the output channel.

Example:

```
input := helper.SliceToChan([]int{2, 4, 6, 8})
output := make(chan int)
helper.Pipe(input, output)
fmt.println(helper.ChanToSlice(output)) // [2, 4, 6, 8]
```

<a name="Pow"></a>
## func [Pow](<https://github.com/cinar/indicator/blob/master/helper/pow.go#L17>)

```go
func Pow[T Number](c <-chan T, y T) <-chan T
```

Pow takes a channel of float64 values and returns the element\-wise base\-value exponential of y.

Example:

```
c := helper.SliceToChan([]int{2, 3, 5, 10})
squared := helper.Pow(c, 2)
fmt.Println(helper.ChanToSlice(squared)) // [4, 9, 25, 100]
```

<a name="ReadFromCsvFile"></a>
## func [ReadFromCsvFile](<https://github.com/cinar/indicator/blob/master/helper/csv.go#L278>)

```go
func ReadFromCsvFile[T any](fileName string, hasHeader bool) (<-chan *T, error)
```

ReadFromCsvFile creates a CSV instance, parses CSV data from the provided filename, maps the data to corresponding struct fields, and delivers it through the channel.

<a name="RoundDigit"></a>
## func [RoundDigit](<https://github.com/cinar/indicator/blob/master/helper/round_digit.go#L15>)

```go
func RoundDigit[T Number](n T, d int) T
```

RoundDigit rounds the given float64 number to d decimal places.

Example:

```
n := helper.RoundDigit(10.1234, 2)
fmt.Println(n) // 10.12
```

<a name="RoundDigits"></a>
## func [RoundDigits](<https://github.com/cinar/indicator/blob/master/helper/round_digits.go#L15>)

```go
func RoundDigits[T Number](c <-chan T, d int) <-chan T
```

RoundDigits takes a channel of float64 numbers and rounds them to d decimal places.

Example:

```
c := helper.SliceToChan([]float64{10.1234, 5.678, 6.78, 8.91011})
rounded := helper.RoundDigits(c, 2)
fmt.Println(helper.ChanToSlice(rounded)) // [10.12, 5.68, 6.78, 8.91]
```

<a name="Seq"></a>
## func [Seq](<https://github.com/cinar/indicator/blob/master/helper/seq.go#L21>)

```go
func Seq[T Number](from, to, increment T) <-chan T
```

Seq generates a sequence of numbers starting with a specified value, from, and incrementing by a specified amount, increment, until a specified value, to, is reached or exceeded. The sequence includes both from and to.

Example:

```
s := Seq(1, 5, 1)
defer close(s)

fmt.Println(<- s) // 1
fmt.Println(<- s) // 2
fmt.Println(<- s) // 3
fmt.Println(<- s) // 4
```

<a name="Shift"></a>
## func [Shift](<https://github.com/cinar/indicator/blob/master/helper/shift.go#L15>)

```go
func Shift[T any](c <-chan T, count int, fill T) <-chan T
```

Shift takes a channel of numbers, shifts them to the right by the specified count, and fills in any missing values with the provided fill value.

Example:

```
input := helper.SliceToChan([]int{2, 4, 6, 8})
output := helper.Shift(input, 4, 0)
fmt.Println(helper.ChanToSlice(output)) // [0, 0, 0, 0, 2, 4, 6, 8]
```

<a name="Sign"></a>
## func [Sign](<https://github.com/cinar/indicator/blob/master/helper/sign.go#L15>)

```go
func Sign[T Number](c <-chan T) <-chan T
```

Sign takes a channel of float64 values and returns their signs as \-1 for negative, 0 for zero, and 1 for positive.

Example:

```
c := helper.SliceToChan([]int{-10, 20, -4, 0})
sign := helper.Sign(c)
fmt.Println(helper.ChanToSlice(sign)) // [-1, 1, -1, 0]
```

<a name="Since"></a>
## func [Since](<https://github.com/cinar/indicator/blob/master/helper/since.go#L9>)

```go
func Since[T comparable, R Number](c <-chan T) <-chan R
```

Since counts the number of periods since the last change of value in a channel of numbers.

<a name="Skip"></a>
## func [Skip](<https://github.com/cinar/indicator/blob/master/helper/skip.go#L15>)

```go
func Skip[T any](c <-chan T, count int) <-chan T
```

Skip skips the specified number of elements from the given channel of float64.

Example:

```
c := helper.SliceToChan([]int{2, 4, 6, 8})
actual := helper.Skip(c, 2)
fmt.Println(helper.ChanToSlice(actual)) // [6, 8]
```

<a name="SliceToChan"></a>
## func [SliceToChan](<https://github.com/cinar/indicator/blob/master/helper/slice_to_chan.go#L17>)

```go
func SliceToChan[T any](slice []T) <-chan T
```

SliceToChan converts a slice of float64 to a channel of float64.

Example:

```
slice := []float64{2, 4, 6, 8}
c := helper.SliceToChan(slice)
fmt.Println(<- c)  // 2
fmt.Println(<- c)  // 4
fmt.Println(<- c)  // 6
fmt.Println(<- c)  // 8
```

<a name="Sqrt"></a>
## func [Sqrt](<https://github.com/cinar/indicator/blob/master/helper/sqrt.go#L16>)

```go
func Sqrt[T Number](c <-chan T) <-chan T
```

Sqrt calculates the square root of each value in a channel of float64.

Example:

```
c := helper.SliceToChan([]int{9, 81, 16, 100})
sqrt := helper.Sqrt(c)
fmt.Println(helper.ChanToSlice(sqrt)) // [3, 9, 4, 10]
```

<a name="Subtract"></a>
## func [Subtract](<https://github.com/cinar/indicator/blob/master/helper/subtract.go#L17>)

```go
func Subtract[T Number](ac, bc <-chan T) <-chan T
```

Subtract takes two channels of float64 and subtracts the values from the second channel from the first one. It returns a new channel containing the results of the subtractions.

Example:

```
ac := helper.SliceToChan([]int{2, 4, 6, 8, 10})
bc := helper.SliceToChan([]int{1, 2, 3, 4, 5})
actual := helper.Subtract(ac, bc)
fmt.Println(helper.ChanToSlice(actual)) // [1, 2, 3, 4, 5]
```

<a name="SyncPeriod"></a>
## func [SyncPeriod](<https://github.com/cinar/indicator/blob/master/helper/sync.go#L29>)

```go
func SyncPeriod[T any](commonPeriod, period int, c <-chan T) <-chan T
```

SyncPeriod adjusts the given channel to match the given common period.

<a name="Waitable"></a>
## func [Waitable](<https://github.com/cinar/indicator/blob/master/helper/waitable.go#L11>)

```go
func Waitable[T any](wg *sync.WaitGroup, c <-chan T) <-chan T
```

Waitable increments the wait group before reading from the channel and signals completion when the channel is closed.

<a name="Bst"></a>
## type [Bst](<https://github.com/cinar/indicator/blob/master/helper/bst.go#L15-L17>)

Bst represents the binary search tree.

```go
type Bst[T Number] struct {
    // contains filtered or unexported fields
}
```

<a name="NewBst"></a>
### func [NewBst](<https://github.com/cinar/indicator/blob/master/helper/bst.go#L20>)

```go
func NewBst[T Number]() *Bst[T]
```

NewBst creates a new binary search tree.

<a name="Bst[T].Contains"></a>
### func \(\*Bst\[T\]\) [Contains](<https://github.com/cinar/indicator/blob/master/helper/bst.go#L57>)

```go
func (b *Bst[T]) Contains(value T) bool
```

Contains checks whether the given value exists in the binary search tree.

<a name="Bst[T].Insert"></a>
### func \(\*Bst\[T\]\) [Insert](<https://github.com/cinar/indicator/blob/master/helper/bst.go#L25>)

```go
func (b *Bst[T]) Insert(value T)
```

Insert adds a new value to the binary search tree.

<a name="Bst[T].Max"></a>
### func \(\*Bst\[T\]\) [Max](<https://github.com/cinar/indicator/blob/master/helper/bst.go#L85>)

```go
func (b *Bst[T]) Max() T
```

Max function returns the maximum value in the binary search tree.

<a name="Bst[T].Min"></a>
### func \(\*Bst\[T\]\) [Min](<https://github.com/cinar/indicator/blob/master/helper/bst.go#L75>)

```go
func (b *Bst[T]) Min() T
```

Min function returns the minimum value in the binary search tree.

<a name="Bst[T].Remove"></a>
### func \(\*Bst\[T\]\) [Remove](<https://github.com/cinar/indicator/blob/master/helper/bst.go#L64>)

```go
func (b *Bst[T]) Remove(value T) bool
```

Remove removes the specified value from the binary search tree and rebalances the tree.

<a name="BstNode"></a>
## type [BstNode](<https://github.com/cinar/indicator/blob/master/helper/bst.go#L8-L12>)

BstNode represents the binary search tree node.

```go
type BstNode[T Number] struct {
    // contains filtered or unexported fields
}
```

<a name="Csv"></a>
## type [Csv](<https://github.com/cinar/indicator/blob/master/helper/csv.go#L40-L50>)

Csv represents the configuration for CSV reader and writer.

```go
type Csv[T any] struct {

    // Logger is the slog logger instance.
    Logger *slog.Logger
    // contains filtered or unexported fields
}
```

<a name="NewCsv"></a>
### func [NewCsv](<https://github.com/cinar/indicator/blob/master/helper/csv.go#L54>)

```go
func NewCsv[T any](hasHeader bool) (*Csv[T], error)
```

NewCsv function initializes a new CSV instance. The parameter hasHeader indicates whether the CSV contains a header row.

<a name="Csv[T].AppendToFile"></a>
### func \(\*Csv\[T\]\) [AppendToFile](<https://github.com/cinar/indicator/blob/master/helper/csv.go#L174>)

```go
func (c *Csv[T]) AppendToFile(fileName string, rows <-chan *T) error
```

AppendToFile appends the provided rows of data to the end of the specified file, creating the file if it doesn't exist. In append mode, the function assumes that the existing file's column order matches the field order of the given row struct to ensure consistent data structure.

<a name="Csv[T].ReadFromFile"></a>
### func \(\*Csv\[T\]\) [ReadFromFile](<https://github.com/cinar/indicator/blob/master/helper/csv.go#L150>)

```go
func (c *Csv[T]) ReadFromFile(fileName string) (<-chan *T, error)
```

ReadFromFile parses the CSV data from the provided file name, maps the data to corresponding struct fields, and delivers the resulting rows through the channel.

<a name="Csv[T].ReadFromReader"></a>
### func \(\*Csv\[T\]\) [ReadFromReader](<https://github.com/cinar/indicator/blob/master/helper/csv.go#L95>)

```go
func (c *Csv[T]) ReadFromReader(reader io.Reader) <-chan *T
```

ReadFromReader parses the CSV data from the provided reader, maps the data to corresponding struct fields, and delivers the resulting it through the channel.

<a name="Csv[T].WriteToFile"></a>
### func \(\*Csv\[T\]\) [WriteToFile](<https://github.com/cinar/indicator/blob/master/helper/csv.go#L190>)

```go
func (c *Csv[T]) WriteToFile(fileName string, rows <-chan *T) error
```

WriteToFile creates a new file with the given name and writes the provided rows of data to it, overwriting any existing content.

<a name="Float"></a>
## type [Float](<https://github.com/cinar/indicator/blob/master/helper/helper.go#L27-L29>)

Float refers to any float type.

```go
type Float interface {
    // contains filtered or unexported methods
}
```

<a name="Integer"></a>
## type [Integer](<https://github.com/cinar/indicator/blob/master/helper/helper.go#L22-L24>)

Integer refers to any integer type.

```go
type Integer interface {
    // contains filtered or unexported methods
}
```

<a name="Number"></a>
## type [Number](<https://github.com/cinar/indicator/blob/master/helper/helper.go#L32-L34>)

Number refers to any numeric type.

```go
type Number interface {
    // contains filtered or unexported methods
}
```

<a name="Report"></a>
## type [Report](<https://github.com/cinar/indicator/blob/master/helper/report.go#L48-L55>)

Report generates an HTML file containing an interactive chart that visually represents the provided data and annotations.

The generated HTML file can be opened in a web browser to explore the data visually, interact with the chart elements, and view the associated annotations.

```go
type Report struct {
    Title       string
    Date        <-chan time.Time
    Columns     []ReportColumn
    Views       [][]int
    DateFormat  string
    GeneratedOn string
}
```

<a name="NewReport"></a>
### func [NewReport](<https://github.com/cinar/indicator/blob/master/helper/report.go#L60>)

```go
func NewReport(title string, date <-chan time.Time) *Report
```

NewReport takes a channel of time as the time axis and returns a new instance of the Report struct. This instance can later be used to add data and annotations and subsequently generate a report.

<a name="Report.AddChart"></a>
### func \(\*Report\) [AddChart](<https://github.com/cinar/indicator/blob/master/helper/report.go#L76>)

```go
func (r *Report) AddChart() int
```

AddChart adds a new chart to the report and returns its unique identifier. This identifier can be used later to refer to the chart and add columns to it.

<a name="Report.AddColumn"></a>
### func \(\*Report\) [AddColumn](<https://github.com/cinar/indicator/blob/master/helper/report.go#L83>)

```go
func (r *Report) AddColumn(column ReportColumn, charts ...int)
```

AddColumn adds a new data column to the specified charts. If no chart is specified, it will be added to the main chart.

<a name="Report.WriteToFile"></a>
### func \(\*Report\) [WriteToFile](<https://github.com/cinar/indicator/blob/master/helper/report.go#L111>)

```go
func (r *Report) WriteToFile(fileName string) error
```

WriteToFile writes the generated report content to a file with the specified name. This allows users to conveniently save the report for later viewing or analysis.

<a name="Report.WriteToWriter"></a>
### func \(\*Report\) [WriteToWriter](<https://github.com/cinar/indicator/blob/master/helper/report.go#L99>)

```go
func (r *Report) WriteToWriter(writer io.Writer) error
```

WriteToWriter writes the report content to the provided io.Writer. This allows the report to be sent to various destinations, such as a file, a network socket, or even the standard output.

<a name="ReportColumn"></a>
## type [ReportColumn](<https://github.com/cinar/indicator/blob/master/helper/report.go#L28-L40>)

ReportColumn defines the interface that all report data columns must implement. This interface ensures that different types of data columns can be used consistently within the report generation process.

```go
type ReportColumn interface {
    // Name returns the name of the report column.
    Name() string

    // Type returns the data type of the report column.
    Type() string

    // Role returns the role of the report column.
    Role() string

    // Value returns the next data value for the report column.
    Value() string
}
```

<a name="NewAnnotationReportColumn"></a>
### func [NewAnnotationReportColumn](<https://github.com/cinar/indicator/blob/master/helper/annotation_report_column.go#L16>)

```go
func NewAnnotationReportColumn(values <-chan string) ReportColumn
```

NewAnnotationReportColumn returns a new instance of a annotation column for a report.

<a name="NewNumericReportColumn"></a>
### func [NewNumericReportColumn](<https://github.com/cinar/indicator/blob/master/helper/numeric_report_column.go#L17>)

```go
func NewNumericReportColumn[T Number](name string, values <-chan T) ReportColumn
```

NewNumericReportColumn returns a new instance of a numeric data column for a report.

<a name="Ring"></a>
## type [Ring](<https://github.com/cinar/indicator/blob/master/helper/ring.go#L18-L23>)

Ring represents a ring structure that can be instantiated using the NewRing function.

Example:

```
ring := helper.NewRing[int](2)

fmt.Println(ring.Insert(1)) // 0
fmt.Println(ring.Insert(2)) // 0
fmt.Println(ring.Insert(3)) // 1
fmt.Println(ring.Insert(4)) // 2
```

```go
type Ring[T any] struct {
    // contains filtered or unexported fields
}
```

<a name="NewRing"></a>
### func [NewRing](<https://github.com/cinar/indicator/blob/master/helper/ring.go#L26>)

```go
func NewRing[T any](size int) *Ring[T]
```

NewRing creates a new ring instance with the given size.

<a name="Ring[T].At"></a>
### func \(\*Ring\[T\]\) [At](<https://github.com/cinar/indicator/blob/master/helper/ring.go#L71>)

```go
func (r *Ring[T]) At(index int) T
```

At returns the value at the given index.

<a name="Ring[T].Get"></a>
### func \(\*Ring\[T\]\) [Get](<https://github.com/cinar/indicator/blob/master/helper/ring.go#L53>)

```go
func (r *Ring[T]) Get() (T, bool)
```

Get retrieves the available value from the ring buffer. If empty, it returns the default value \(T\) and false.

<a name="Ring[T].IsEmpty"></a>
### func \(\*Ring\[T\]\) [IsEmpty](<https://github.com/cinar/indicator/blob/master/helper/ring.go#L76>)

```go
func (r *Ring[T]) IsEmpty() bool
```

IsEmpty checks if the current ring buffer is empty.

<a name="Ring[T].IsFull"></a>
### func \(\*Ring\[T\]\) [IsFull](<https://github.com/cinar/indicator/blob/master/helper/ring.go#L81>)

```go
func (r *Ring[T]) IsFull() bool
```

IsFull checks if the current ring buffer is full.

<a name="Ring[T].Put"></a>
### func \(\*Ring\[T\]\) [Put](<https://github.com/cinar/indicator/blob/master/helper/ring.go#L37>)

```go
func (r *Ring[T]) Put(t T) T
```

Put inserts the specified value into the ring and returns the value that was previously stored at that index.

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
