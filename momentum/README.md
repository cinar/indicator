<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# momentum

```go
import "github.com/cinar/indicator/v2/momentum"
```

Package momentum contains the momentum indicator functions.

This package belongs to the Indicator project. Indicator is a Golang module that supplies a variety of technical indicators, strategies, and a backtesting framework for analysis.

### License

```
Copyright (c) 2021-2024 Onur Cinar.
The source code is provided under GNU AGPLv3 License.
https://github.com/cinar/indicator
```

### Disclaimer

The information provided on this project is strictly for informational purposes and is not to be construed as advice or solicitation to buy or sell any security.

## Index

- [Constants](<#constants>)
- [type AwesomeOscillator](<#AwesomeOscillator>)
  - [func NewAwesomeOscillator\[T helper.Number\]\(\) \*AwesomeOscillator\[T\]](<#NewAwesomeOscillator>)
  - [func \(a \*AwesomeOscillator\[T\]\) Compute\(highs, lows \<\-chan T\) \<\-chan T](<#AwesomeOscillator[T].Compute>)
  - [func \(a \*AwesomeOscillator\[T\]\) IdlePeriod\(\) int](<#AwesomeOscillator[T].IdlePeriod>)
- [type ChaikinOscillator](<#ChaikinOscillator>)
  - [func NewChaikinOscillator\[T helper.Number\]\(\) \*ChaikinOscillator\[T\]](<#NewChaikinOscillator>)
  - [func \(c \*ChaikinOscillator\[T\]\) Compute\(highs, lows, closings, volumes \<\-chan T\) \(\<\-chan T, \<\-chan T\)](<#ChaikinOscillator[T].Compute>)
  - [func \(c \*ChaikinOscillator\[T\]\) IdlePeriod\(\) int](<#ChaikinOscillator[T].IdlePeriod>)
- [type IchimokuCloud](<#IchimokuCloud>)
  - [func NewIchimokuCloud\[T helper.Number\]\(\) \*IchimokuCloud\[T\]](<#NewIchimokuCloud>)
  - [func \(i \*IchimokuCloud\[T\]\) Compute\(highs, lows, closings \<\-chan T\) \(\<\-chan T, \<\-chan T, \<\-chan T, \<\-chan T, \<\-chan T\)](<#IchimokuCloud[T].Compute>)
  - [func \(i \*IchimokuCloud\[T\]\) IdlePeriod\(\) int](<#IchimokuCloud[T].IdlePeriod>)
- [type Ppo](<#Ppo>)
  - [func NewPpo\[T helper.Number\]\(\) \*Ppo\[T\]](<#NewPpo>)
  - [func \(p \*Ppo\[T\]\) Compute\(closings \<\-chan T\) \(\<\-chan T, \<\-chan T, \<\-chan T\)](<#Ppo[T].Compute>)
  - [func \(p \*Ppo\[T\]\) IdlePeriod\(\) int](<#Ppo[T].IdlePeriod>)
- [type Pvo](<#Pvo>)
  - [func NewPvo\[T helper.Number\]\(\) \*Pvo\[T\]](<#NewPvo>)
  - [func \(p \*Pvo\[T\]\) Compute\(volumes \<\-chan T\) \(\<\-chan T, \<\-chan T, \<\-chan T\)](<#Pvo[T].Compute>)
  - [func \(p \*Pvo\[T\]\) IdlePeriod\(\) int](<#Pvo[T].IdlePeriod>)
- [type Qstick](<#Qstick>)
  - [func NewQstick\[T helper.Number\]\(\) \*Qstick\[T\]](<#NewQstick>)
  - [func \(q \*Qstick\[T\]\) Compute\(openings \<\-chan T, closings \<\-chan T\) \<\-chan T](<#Qstick[T].Compute>)
  - [func \(q \*Qstick\[T\]\) IdlePeriod\(\) int](<#Qstick[T].IdlePeriod>)
- [type Rsi](<#Rsi>)
  - [func NewRsi\[T helper.Number\]\(\) \*Rsi\[T\]](<#NewRsi>)
  - [func NewRsiWithPeriod\[T helper.Number\]\(period int\) \*Rsi\[T\]](<#NewRsiWithPeriod>)
  - [func \(r \*Rsi\[T\]\) Compute\(closings \<\-chan T\) \<\-chan T](<#Rsi[T].Compute>)
  - [func \(r \*Rsi\[T\]\) IdlePeriod\(\) int](<#Rsi[T].IdlePeriod>)
- [type StochasticOscillator](<#StochasticOscillator>)
  - [func NewStochasticOscillator\[T helper.Number\]\(\) \*StochasticOscillator\[T\]](<#NewStochasticOscillator>)
  - [func \(s \*StochasticOscillator\[T\]\) Compute\(highs, lows, closings \<\-chan T\) \(\<\-chan T, \<\-chan T\)](<#StochasticOscillator[T].Compute>)
  - [func \(s \*StochasticOscillator\[T\]\) IdlePeriod\(\) int](<#StochasticOscillator[T].IdlePeriod>)
- [type WilliamsR](<#WilliamsR>)
  - [func NewWilliamsR\[T helper.Number\]\(\) \*WilliamsR\[T\]](<#NewWilliamsR>)
  - [func \(w \*WilliamsR\[T\]\) Compute\(highs, lows, closings \<\-chan T\) \<\-chan T](<#WilliamsR[T].Compute>)
  - [func \(w \*WilliamsR\[T\]\) IdlePeriod\(\) int](<#WilliamsR[T].IdlePeriod>)


## Constants

<a name="DefaultAwesomeOscillatorShortPeriod"></a>

```go
const (
    // DefaultAwesomeOscillatorShortPeriod is the default short period for the Awesome Oscillator (AO).
    DefaultAwesomeOscillatorShortPeriod = 5

    // DefaultAwesomeOscillatorLongPeriod is the default long period for the Awesome Oscillator (AO).
    DefaultAwesomeOscillatorLongPeriod = 34
)
```

<a name="DefaultChaikinOscillatorShortPeriod"></a>

```go
const (
    // DefaultChaikinOscillatorShortPeriod is the default short period for the Chaikin Oscillator.
    DefaultChaikinOscillatorShortPeriod = 3

    // DefaultChaikinOscillatorLongPeriod is the default long period for the Chaikin Oscillator.
    DefaultChaikinOscillatorLongPeriod = 10
)
```

<a name="DefaultIchimokuCloudConversionPeriod"></a>

```go
const (
    // DefaultIchimokuCloudConversionPeriod is the default conversion period for the Ichimoku Cloud.
    DefaultIchimokuCloudConversionPeriod = 9

    // DefaultIchimokuCloudBasePeriod is the default base period for the Ichimoku Cloud.
    DefaultIchimokuCloudBasePeriod = 26

    // DefaultIchimokuCloudLeadingPeriod is the default leading period for the Ichimoku Cloud.
    DefaultIchimokuCloudLeadingPeriod = 52

    // DefaultIchimokuCloudLaggingPeriod is the default lagging period for the Ichimoku Cloud.
    DefaultIchimokuCloudLaggingPeriod = 26
)
```

<a name="DefaultPpoShortPeriod"></a>

```go
const (
    // DefaultPpoShortPeriod is the default short period for the Percentage Price Oscillator.
    DefaultPpoShortPeriod = 12

    // DefaultPpoLongPeriod is the default long period for the Percentage Price Oscillator.
    DefaultPpoLongPeriod = 26

    // DefaultPpoSignalPeriod is the default signal period for the Percentage Price Oscillator.
    DefaultPpoSignalPeriod = 9
)
```

<a name="DefaultPvoShortPeriod"></a>

```go
const (
    // DefaultPvoShortPeriod is the default short period for the Percentage Volume Oscillator.
    DefaultPvoShortPeriod = 12

    // DefaultPvoLongPeriod is the default long period for the Percentage Volume Oscillator.
    DefaultPvoLongPeriod = 26

    // DefaultPvoSignalPeriod is the default signal period for the Percentage Volume Oscillator.
    DefaultPvoSignalPeriod = 9
)
```

<a name="DefaultStochasticOscillatorMaxAndMinPeriod"></a>

```go
const (
    // DefaultStochasticOscillatorMaxAndMinPeriod is the default max and min period for the Stochastic Oscillator.
    DefaultStochasticOscillatorMaxAndMinPeriod = 14

    // DefaultStochasticOscillatorPeriod is the default period for the Stochastic Oscillator.
    DefaultStochasticOscillatorPeriod = 3
)
```

<a name="DefaultQstickPeriod"></a>

```go
const (
    // DefaultQstickPeriod is the default period for the Qstick SMA.
    DefaultQstickPeriod = 20
)
```

<a name="DefaultRsiPeriod"></a>

```go
const (
    // DefaultRsiPeriod is the default period for the Relative Strength Index (RSI).
    DefaultRsiPeriod = 14
)
```

<a name="DefaultWilliamsRPeriod"></a>

```go
const (
    // DefaultWilliamsRPeriod is the default period for the Williams R.
    DefaultWilliamsRPeriod = 14
)
```

<a name="AwesomeOscillator"></a>
## type [AwesomeOscillator](<https://github.com/cinar/indicator/blob/v2/momentum/awesome_oscillator.go#L33-L39>)

AwesomeOscillator represents the configuration parameter for calculating the Awesome Oscillator \(AO\). It gauges market momentum by comparing short\-term price action \(5\-period average\) against long\-term trends \(34\-period average\). Its value around a zero line reflects bullishness above and bearishness below. Crossings of the zero line can signal potential trend reversals. Traders use the AO to confirm existing trends, identify entry/exit points, and understand momentum shifts.

```
Median Price = ((Low + High) / 2).
AO = 5-Period SMA - 34-Period SMA.
```

Example:

```
ao := momentum.AwesomeOscillator[float64]()
values := ao.Compute(lows, highs)
```

```go
type AwesomeOscillator[T helper.Number] struct {
    // ShortSma is the SMA for the short period.
    ShortSma *trend.Sma[T]

    // LongSma is the SMA for the long period.
    LongSma *trend.Sma[T]
}
```

<a name="NewAwesomeOscillator"></a>
### func [NewAwesomeOscillator](<https://github.com/cinar/indicator/blob/v2/momentum/awesome_oscillator.go#L42>)

```go
func NewAwesomeOscillator[T helper.Number]() *AwesomeOscillator[T]
```

NewAwesomeOscillator function initializes a new Awesome Oscillator instance.

<a name="AwesomeOscillator[T].Compute"></a>
### func \(\*AwesomeOscillator\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/v2/momentum/awesome_oscillator.go#L50>)

```go
func (a *AwesomeOscillator[T]) Compute(highs, lows <-chan T) <-chan T
```

Compute function takes a channel of numbers and computes the AwesomeOscillator.

<a name="AwesomeOscillator[T].IdlePeriod"></a>
### func \(\*AwesomeOscillator\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/v2/momentum/awesome_oscillator.go#L71>)

```go
func (a *AwesomeOscillator[T]) IdlePeriod() int
```

IdlePeriod is the initial period that Awesome Oscillator won't yield any results.

<a name="ChaikinOscillator"></a>
## type [ChaikinOscillator](<https://github.com/cinar/indicator/blob/v2/momentum/chaikin_oscillator.go#L32-L41>)

ChaikinOscillator represents the configuration parameter for calculating the Chaikin Oscillator. It measures the momentum of the Accumulation/Distribution \(A/D\) using the Moving Average Convergence Divergence \(MACD\) formula. It takes the difference between fast and slow periods EMA of the A/D. Cross above the A/D line indicates bullish.

```
CO = Ema(fastPeriod, AD) - Ema(slowPeriod, AD)
```

Example:

```
co := momentum.ChaikinOscillator[float64]()
values := co.Compute(lows, highs)
```

```go
type ChaikinOscillator[T helper.Number] struct {
    // Ad is the Accumulation/Distribution (A/D) instance.
    Ad  *volume.Ad[T]

    // ShortEma is the SMA for the short period.
    ShortEma *trend.Ema[T]

    // LongEma is the SMA for the long period.
    LongEma *trend.Ema[T]
}
```

<a name="NewChaikinOscillator"></a>
### func [NewChaikinOscillator](<https://github.com/cinar/indicator/blob/v2/momentum/chaikin_oscillator.go#L44>)

```go
func NewChaikinOscillator[T helper.Number]() *ChaikinOscillator[T]
```

NewChaikinOscillator function initializes a new Chaikin Oscillator instance.

<a name="ChaikinOscillator[T].Compute"></a>
### func \(\*ChaikinOscillator\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/v2/momentum/chaikin_oscillator.go#L53>)

```go
func (c *ChaikinOscillator[T]) Compute(highs, lows, closings, volumes <-chan T) (<-chan T, <-chan T)
```

Compute function takes a channel of numbers and computes the Chaikin Oscillator.

<a name="ChaikinOscillator[T].IdlePeriod"></a>
### func \(\*ChaikinOscillator\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/v2/momentum/chaikin_oscillator.go#L71>)

```go
func (c *ChaikinOscillator[T]) IdlePeriod() int
```

IdlePeriod is the initial period that Chaikin Oscillator won't yield any results.

<a name="IchimokuCloud"></a>
## type [IchimokuCloud](<https://github.com/cinar/indicator/blob/v2/momentum/ichimoku_cloud.go#L40-L61>)

IchimokuCloud represents the configuration parameter for calculating the Ichimoku Cloud. It is also known as the Ichimoku Kinko Hyo, is a versatile indicator that defines support and resistence, identifies trend direction, gauges momentum, and provides trading signals.

```
Tenkan-sen (Conversion Line) = (9-Period High + 9-Period Low) / 2
Kijun-sen (Base Line) = (26-Period High + 26-Period Low) / 2
Senkou Span A (Leading Span A) = (Conversion Line + Base Line) / 2
Senkou Span B (Leading Span B) = (52-Period High + 52-Period Low) / 2
Chikou Span (Lagging Span) = Closing plotted 26 days in the past.
```

Example:

```
ic := momentum.IchimokuCloud[float64]()
conversionLine, baseLine, leadingSpanA, leasingSpanB, laggingSpan := ic.Compute(highs, lows, closings)
```

```go
type IchimokuCloud[T helper.Number] struct {
    // ConversionMax is the conversion Moving Max instance.
    ConversionMax *trend.MovingMax[T]

    // ConversionMin is the conversion Moving Min instance.
    ConversionMin *trend.MovingMin[T]

    // BaseMax is the base Moving Max instance.
    BaseMax *trend.MovingMax[T]

    // BaseMin is the base Moving Min instance.
    BaseMin *trend.MovingMin[T]

    // LeadingMax is the leading Moving Max instance.
    LeadingMax *trend.MovingMax[T]

    // LeadingMin is the leading Moving Min instance.
    LeadingMin *trend.MovingMin[T]

    // LaggingPeriod is the lagging period.
    LaggingPeriod int
}
```

<a name="NewIchimokuCloud"></a>
### func [NewIchimokuCloud](<https://github.com/cinar/indicator/blob/v2/momentum/ichimoku_cloud.go#L64>)

```go
func NewIchimokuCloud[T helper.Number]() *IchimokuCloud[T]
```

NewIchimokuCloud function initializes a new Ichimoku Cloud instance.

<a name="IchimokuCloud[T].Compute"></a>
### func \(\*IchimokuCloud\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/v2/momentum/ichimoku_cloud.go#L78>)

```go
func (i *IchimokuCloud[T]) Compute(highs, lows, closings <-chan T) (<-chan T, <-chan T, <-chan T, <-chan T, <-chan T)
```

Compute function takes a channel of numbers and computes the Ichimoku Cloud. Returns conversionLine, baseLine, leadingSpanA, leadingSpanB, laggingSpan

<a name="IchimokuCloud[T].IdlePeriod"></a>
### func \(\*IchimokuCloud\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/v2/momentum/ichimoku_cloud.go#L139>)

```go
func (i *IchimokuCloud[T]) IdlePeriod() int
```

IdlePeriod is the initial period that Ichimoku Cloud won't yield any results.

<a name="Ppo"></a>
## type [Ppo](<https://github.com/cinar/indicator/blob/v2/momentum/ppo.go#L35-L44>)

Ppo represents the configuration parameter for calculating the Percentage Price Oscillator \(PPO\). It is a momentum oscillator for the price. It is used to indicate the ups and downs based on the price. A breakout is confirmed when PPO is positive.

```
PPO = ((EMA(shortPeriod, prices) - EMA(longPeriod, prices)) / EMA(longPeriod, prices)) * 100
Signal = EMA(9, PPO)
Histogram = PPO - Signal
```

Example:

```
ppo := momentum.Ppo[float64]()
p, s, h := ppo.Compute(closings)
```

```go
type Ppo[T helper.Number] struct {
    // ShortEma is the short EMA instance.
    ShortEma *trend.Ema[T]

    // LongEma is the long EMA instance.
    LongEma *trend.Ema[T]

    // SignalEma is the signal EMA instance.
    SignalEma *trend.Ema[T]
}
```

<a name="NewPpo"></a>
### func [NewPpo](<https://github.com/cinar/indicator/blob/v2/momentum/ppo.go#L47>)

```go
func NewPpo[T helper.Number]() *Ppo[T]
```

NewPpo function initializes a new Percentage Price Oscillator instance.

<a name="Ppo[T].Compute"></a>
### func \(\*Ppo\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/v2/momentum/ppo.go#L57>)

```go
func (p *Ppo[T]) Compute(closings <-chan T) (<-chan T, <-chan T, <-chan T)
```

Compute function takes a channel of numbers and computes the Percentage Price Oscillator. Returns ppo, signal, histogram.

<a name="Ppo[T].IdlePeriod"></a>
### func \(\*Ppo\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/v2/momentum/ppo.go#L100>)

```go
func (p *Ppo[T]) IdlePeriod() int
```

IdlePeriod is the initial period that Percentage Price Oscillator won't yield any results.

<a name="Pvo"></a>
## type [Pvo](<https://github.com/cinar/indicator/blob/v2/momentum/pvo.go#L35-L44>)

Pvo represents the configuration parameter for calculating the Percentage Volume Oscillator \(PVO\). It is a momentum oscillator for the price. It is used to indicate the ups and downs based on the price. A breakout is confirmed when PVO is positive.

```
PVO = ((EMA(shortPeriod, prices) - EMA(longPeriod, prices)) / EMA(longPeriod, prices)) * 100
Signal = EMA(9, PVO)
Histogram = PVO - Signal
```

Example:

```
pvo := momentum.Pvo[float64]()
p, s, h := pvo.Compute(volumes)
```

```go
type Pvo[T helper.Number] struct {
    // ShortEma is the short EMA instance.
    ShortEma *trend.Ema[T]

    // LongEma is the long EMA instance.
    LongEma *trend.Ema[T]

    // SignalEma is the signal EMA instance.
    SignalEma *trend.Ema[T]
}
```

<a name="NewPvo"></a>
### func [NewPvo](<https://github.com/cinar/indicator/blob/v2/momentum/pvo.go#L47>)

```go
func NewPvo[T helper.Number]() *Pvo[T]
```

NewPvo function initializes a new Percentage Volume Oscillator instance.

<a name="Pvo[T].Compute"></a>
### func \(\*Pvo\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/v2/momentum/pvo.go#L57>)

```go
func (p *Pvo[T]) Compute(volumes <-chan T) (<-chan T, <-chan T, <-chan T)
```

Compute function takes a channel of numbers and computes the Percentage Volume Oscillator. Returns pvo, signal, histogram.

<a name="Pvo[T].IdlePeriod"></a>
### func \(\*Pvo\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/v2/momentum/pvo.go#L100>)

```go
func (p *Pvo[T]) IdlePeriod() int
```

IdlePeriod is the initial period that Percentage Volume Oscillator won't yield any results.

<a name="Qstick"></a>
## type [Qstick](<https://github.com/cinar/indicator/blob/v2/momentum/qstick.go#L33-L35>)

Qstick represents the configuration parameter for calculating the Qstick indicator. Qstick is a momentum indicator used to identify an asset's trend by looking at the SMA of the difference between its closing and opening.

A Qstick above zero indicates increasing buying pressure, while a Qstick below zero indicates increasing selling pressure.

```
QS = SMA(Closings - Openings)
```

Example:

```
qstick := momentum.Qstick[float64]()
qstick.Sma.Period = 50

values := qstick.Compute(openings, closings)
```

```go
type Qstick[T helper.Number] struct {
    Sma *trend.Sma[T]
}
```

<a name="NewQstick"></a>
### func [NewQstick](<https://github.com/cinar/indicator/blob/v2/momentum/qstick.go#L38>)

```go
func NewQstick[T helper.Number]() *Qstick[T]
```

NewQstick function initializes a new QStick instance.

<a name="Qstick[T].Compute"></a>
### func \(\*Qstick\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/v2/momentum/qstick.go#L49>)

```go
func (q *Qstick[T]) Compute(openings <-chan T, closings <-chan T) <-chan T
```

Compute function takes a channel of numbers and computes the Qstick.

<a name="Qstick[T].IdlePeriod"></a>
### func \(\*Qstick\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/v2/momentum/qstick.go#L57>)

```go
func (q *Qstick[T]) IdlePeriod() int
```

IdlePeriod is the initial period that Qstick won't yield any results.

<a name="Rsi"></a>
## type [Rsi](<https://github.com/cinar/indicator/blob/v2/momentum/rsi.go#L27-L30>)

Rsi represents the configuration parameter for calculating the Relative Strength Index \(RSI\). It is a momentum indicator that measures the magnitude of recent price changes to evaluate overbought and oversold conditions.

```
RS = Average Gain / Average Loss
RSI = 100 - (100 / (1 + RS))
```

Example:

```
rsi := momentum.NewRsi[float64]()
result := rsi.Compute(closings)
```

```go
type Rsi[T helper.Number] struct {
    // Rma is the RMA instance.
    Rma *trend.Rma[T]
}
```

<a name="NewRsi"></a>
### func [NewRsi](<https://github.com/cinar/indicator/blob/v2/momentum/rsi.go#L33>)

```go
func NewRsi[T helper.Number]() *Rsi[T]
```

NewRsi function initializes a new Relative Strength Index instance with the default parameters.

<a name="NewRsiWithPeriod"></a>
### func [NewRsiWithPeriod](<https://github.com/cinar/indicator/blob/v2/momentum/rsi.go#L38>)

```go
func NewRsiWithPeriod[T helper.Number](period int) *Rsi[T]
```

NewRsiWithPeriod function initializes a new Relative Strength Index instance with the given period.

<a name="Rsi[T].Compute"></a>
### func \(\*Rsi\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/v2/momentum/rsi.go#L45>)

```go
func (r *Rsi[T]) Compute(closings <-chan T) <-chan T
```

Compute function takes a channel of closings numbers and computes the Relative Strength Index.

<a name="Rsi[T].IdlePeriod"></a>
### func \(\*Rsi\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/v2/momentum/rsi.go#L90>)

```go
func (r *Rsi[T]) IdlePeriod() int
```

IdlePeriod is the initial period that Relative Strength Index won't yield any results.

<a name="StochasticOscillator"></a>
## type [StochasticOscillator](<https://github.com/cinar/indicator/blob/v2/momentum/stochastic_oscillator.go#L31-L40>)

StochasticOscillator represents the configuration parameter for calculating the Stochastic Oscillator. It is a momentum indicator that shows the location of the closing relative to high\-low range over a set number of periods.

```
K = (Closing - Lowest Low) / (Highest High - Lowest Low) * 100
D = 3-Period SMA of K
```

Example:

```
so := momentum.StochasticOscillator[float64]()
k, d := wr.Compute(highs, lows, closings)
```

```go
type StochasticOscillator[T helper.Number] struct {
    // Max is the Moving Max instance.
    Max *trend.MovingMax[T]

    // Min is the Moving Min instance.
    Min *trend.MovingMin[T]

    // Sma is the SMA instance.
    Sma *trend.Sma[T]
}
```

<a name="NewStochasticOscillator"></a>
### func [NewStochasticOscillator](<https://github.com/cinar/indicator/blob/v2/momentum/stochastic_oscillator.go#L43>)

```go
func NewStochasticOscillator[T helper.Number]() *StochasticOscillator[T]
```

NewStochasticOscillator function initializes a new Stochastic Oscillator instance.

<a name="StochasticOscillator[T].Compute"></a>
### func \(\*StochasticOscillator\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/v2/momentum/stochastic_oscillator.go#L52>)

```go
func (s *StochasticOscillator[T]) Compute(highs, lows, closings <-chan T) (<-chan T, <-chan T)
```

Compute function takes a channel of numbers and computes the Stochastic Oscillator. Returns k and d.

<a name="StochasticOscillator[T].IdlePeriod"></a>
### func \(\*StochasticOscillator\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/v2/momentum/stochastic_oscillator.go#L82>)

```go
func (s *StochasticOscillator[T]) IdlePeriod() int
```

IdlePeriod is the initial period that Stochastic Oscillator won't yield any results.

<a name="WilliamsR"></a>
## type [WilliamsR](<https://github.com/cinar/indicator/blob/v2/momentum/williams_r.go#L29-L35>)

WilliamsR represents the configuration parameter for calculating the Williams %R, or just %R. It is a technical analysis oscillator showing the current closing price in relation to the high and low of the past N days \(for a given N\). It was developed by a publisher and promoter of trading materials, Larry Williams. Its purpose is to tell whether a stock or commodity market is trading near the high or the low, or somewhere in between, of its recent trading range. Buy when \-80 and below. Sell when \-20 and above.

```
WR = (Highest High - Closing) / (Highest High - Lowest Low) * -100.
```

Example:

```
wr := momentum.WilliamsR[float64]()
values := wr.Compute(highs, lows, closings)
```

```go
type WilliamsR[T helper.Number] struct {
    // Max is the Moving Max instance.
    Max *trend.MovingMax[T]

    // Min is the Moving Min instance.
    Min *trend.MovingMin[T]
}
```

<a name="NewWilliamsR"></a>
### func [NewWilliamsR](<https://github.com/cinar/indicator/blob/v2/momentum/williams_r.go#L38>)

```go
func NewWilliamsR[T helper.Number]() *WilliamsR[T]
```

NewWilliamsR function initializes a new Williams R instance.

<a name="WilliamsR[T].Compute"></a>
### func \(\*WilliamsR\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/v2/momentum/williams_r.go#L46>)

```go
func (w *WilliamsR[T]) Compute(highs, lows, closings <-chan T) <-chan T
```

Compute function takes a channel of numbers and computes the Williams R.

<a name="WilliamsR[T].IdlePeriod"></a>
### func \(\*WilliamsR\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/v2/momentum/williams_r.go#L66>)

```go
func (w *WilliamsR[T]) IdlePeriod() int
```

IdlePeriod is the initial period that Williams R won't yield any results.

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
