<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# momentum

```go
import "github.com/cinar/indicator/v2/momentum"
```

Package momentum contains the momentum indicator functions.

This package belongs to the Indicator project. Indicator is a Golang module that supplies a variety of technical indicators, strategies, and a backtesting framework for analysis.

### License

```
Copyright (c) 2021-2026 Onur Cinar.
The source code is provided under GNU AGPLv3 License.
https://github.com/cinar/indicator
```

### Disclaimer

The information provided on this project is strictly for informational purposes and is not to be construed as advice or solicitation to buy or sell any security.

## Index

- [Constants](<#constants>)
- [type AwesomeOscillator](<#AwesomeOscillator>)
  - [func NewAwesomeOscillator\[T helper.Number\]\(\) \*AwesomeOscillator\[T\]](<#NewAwesomeOscillator>)
  - [func \(a \*AwesomeOscillator\[T\]\) Compute\(highs, lows \<\-chan T\) \<\-chan T](<#AwesomeOscillator[T].Compute>)
  - [func \(a \*AwesomeOscillator\[T\]\) IdlePeriod\(\) int](<#AwesomeOscillator[T].IdlePeriod>)
- [type ChaikinOscillator](<#ChaikinOscillator>)
  - [func NewChaikinOscillator\[T helper.Number\]\(\) \*ChaikinOscillator\[T\]](<#NewChaikinOscillator>)
  - [func \(c \*ChaikinOscillator\[T\]\) Compute\(highs, lows, closings, volumes \<\-chan T\) \(\<\-chan T, \<\-chan T\)](<#ChaikinOscillator[T].Compute>)
  - [func \(c \*ChaikinOscillator\[T\]\) IdlePeriod\(\) int](<#ChaikinOscillator[T].IdlePeriod>)
- [type ConnorsRsi](<#ConnorsRsi>)
  - [func NewConnorsRsi\[T helper.Float\]\(\) \*ConnorsRsi\[T\]](<#NewConnorsRsi>)
  - [func NewConnorsRsiWithPeriods\[T helper.Float\]\(rsiPeriod, streakRsiPeriod, percentRankPeriod int\) \*ConnorsRsi\[T\]](<#NewConnorsRsiWithPeriods>)
  - [func \(c \*ConnorsRsi\[T\]\) Compute\(closings \<\-chan T\) \<\-chan T](<#ConnorsRsi[T].Compute>)
  - [func \(c \*ConnorsRsi\[T\]\) IdlePeriod\(\) int](<#ConnorsRsi[T].IdlePeriod>)
  - [func \(c \*ConnorsRsi\[T\]\) String\(\) string](<#ConnorsRsi[T].String>)
- [type Fisher](<#Fisher>)
  - [func NewFisher\[T helper.Float\]\(\) \*Fisher\[T\]](<#NewFisher>)
  - [func \(f \*Fisher\[T\]\) Compute\(closings \<\-chan T\) \<\-chan T](<#Fisher[T].Compute>)
  - [func \(f \*Fisher\[T\]\) IdlePeriod\(\) int](<#Fisher[T].IdlePeriod>)
  - [func \(f \*Fisher\[T\]\) String\(\) string](<#Fisher[T].String>)
- [type IchimokuCloud](<#IchimokuCloud>)
  - [func NewIchimokuCloud\[T helper.Number\]\(\) \*IchimokuCloud\[T\]](<#NewIchimokuCloud>)
  - [func \(i \*IchimokuCloud\[T\]\) Compute\(highs, lows, closings \<\-chan T\) \(\<\-chan T, \<\-chan T, \<\-chan T, \<\-chan T, \<\-chan T\)](<#IchimokuCloud[T].Compute>)
  - [func \(i \*IchimokuCloud\[T\]\) IdlePeriod\(\) int](<#IchimokuCloud[T].IdlePeriod>)
- [type Ppo](<#Ppo>)
  - [func NewPpo\[T helper.Number\]\(\) \*Ppo\[T\]](<#NewPpo>)
  - [func \(p \*Ppo\[T\]\) Compute\(closings \<\-chan T\) \(\<\-chan T, \<\-chan T, \<\-chan T\)](<#Ppo[T].Compute>)
  - [func \(p \*Ppo\[T\]\) IdlePeriod\(\) int](<#Ppo[T].IdlePeriod>)
- [type PringsSpecialK](<#PringsSpecialK>)
  - [func NewPringsSpecialK\[T helper.Float\]\(\) \*PringsSpecialK\[T\]](<#NewPringsSpecialK>)
  - [func \(p \*PringsSpecialK\[T\]\) Compute\(closings \<\-chan T\) \<\-chan T](<#PringsSpecialK[T].Compute>)
- [type Pvo](<#Pvo>)
  - [func NewPvo\[T helper.Number\]\(\) \*Pvo\[T\]](<#NewPvo>)
  - [func \(p \*Pvo\[T\]\) Compute\(volumes \<\-chan T\) \(\<\-chan T, \<\-chan T, \<\-chan T\)](<#Pvo[T].Compute>)
  - [func \(p \*Pvo\[T\]\) IdlePeriod\(\) int](<#Pvo[T].IdlePeriod>)
- [type Qstick](<#Qstick>)
  - [func NewQstick\[T helper.Number\]\(\) \*Qstick\[T\]](<#NewQstick>)
  - [func \(q \*Qstick\[T\]\) Compute\(openings, closings \<\-chan T\) \<\-chan T](<#Qstick[T].Compute>)
  - [func \(q \*Qstick\[T\]\) IdlePeriod\(\) int](<#Qstick[T].IdlePeriod>)
- [type Rsi](<#Rsi>)
  - [func NewRsi\[T helper.Number\]\(\) \*Rsi\[T\]](<#NewRsi>)
  - [func NewRsiWithPeriod\[T helper.Number\]\(period int\) \*Rsi\[T\]](<#NewRsiWithPeriod>)
  - [func \(r \*Rsi\[T\]\) Compute\(closings \<\-chan T\) \<\-chan T](<#Rsi[T].Compute>)
  - [func \(r \*Rsi\[T\]\) IdlePeriod\(\) int](<#Rsi[T].IdlePeriod>)
- [type Rvi](<#Rvi>)
  - [func NewRvi\[T helper.Float\]\(\) \*Rvi\[T\]](<#NewRvi>)
  - [func \(r \*Rvi\[T\]\) Compute\(opens, highs, lows, closings \<\-chan T\) \(rviResult \<\-chan T, signalResult \<\-chan T\)](<#Rvi[T].Compute>)
  - [func \(r \*Rvi\[T\]\) IdlePeriod\(\) int](<#Rvi[T].IdlePeriod>)
  - [func \(r \*Rvi\[T\]\) String\(\) string](<#Rvi[T].String>)
- [type StochasticOscillator](<#StochasticOscillator>)
  - [func NewStochasticOscillator\[T helper.Number\]\(\) \*StochasticOscillator\[T\]](<#NewStochasticOscillator>)
  - [func \(s \*StochasticOscillator\[T\]\) Compute\(highs, lows, closings \<\-chan T\) \(\<\-chan T, \<\-chan T\)](<#StochasticOscillator[T].Compute>)
  - [func \(s \*StochasticOscillator\[T\]\) IdlePeriod\(\) int](<#StochasticOscillator[T].IdlePeriod>)
- [type StochasticRsi](<#StochasticRsi>)
  - [func NewStochasticRsi\[T helper.Number\]\(\) \*StochasticRsi\[T\]](<#NewStochasticRsi>)
  - [func NewStochasticRsiWithPeriod\[T helper.Number\]\(period int\) \*StochasticRsi\[T\]](<#NewStochasticRsiWithPeriod>)
  - [func \(s \*StochasticRsi\[T\]\) Compute\(closings \<\-chan T\) \<\-chan T](<#StochasticRsi[T].Compute>)
  - [func \(s \*StochasticRsi\[T\]\) IdlePeriod\(\) int](<#StochasticRsi[T].IdlePeriod>)
- [type Streak](<#Streak>)
  - [func NewStreak\[T helper.Float\]\(\) \*Streak\[T\]](<#NewStreak>)
  - [func \(s \*Streak\[T\]\) Compute\(closings \<\-chan T\) \<\-chan T](<#Streak[T].Compute>)
  - [func \(s \*Streak\[T\]\) IdlePeriod\(\) int](<#Streak[T].IdlePeriod>)
- [type TdSequential](<#TdSequential>)
  - [func NewTdSequential\[T helper.Number\]\(\) \*TdSequential\[T\]](<#NewTdSequential>)
  - [func \(t \*TdSequential\[T\]\) Compute\(closings \<\-chan T\) \(\<\-chan T, \<\-chan T, \<\-chan T, \<\-chan T\)](<#TdSequential[T].Compute>)
  - [func \(t \*TdSequential\[T\]\) IdlePeriod\(\) int](<#TdSequential[T].IdlePeriod>)
- [type WilliamsR](<#WilliamsR>)
  - [func NewWilliamsR\[T helper.Number\]\(\) \*WilliamsR\[T\]](<#NewWilliamsR>)
  - [func \(w \*WilliamsR\[T\]\) Compute\(highs, lows, closings \<\-chan T\) \<\-chan T](<#WilliamsR[T].Compute>)
  - [func \(w \*WilliamsR\[T\]\) IdlePeriod\(\) int](<#WilliamsR[T].IdlePeriod>)


## Constants

<a name="DefaultAwesomeOscillatorShortPeriod"></a>

```go
const (
    // DefaultAwesomeOscillatorShortPeriod is the default short period for the Awesome Oscillator (AO).
    DefaultAwesomeOscillatorShortPeriod = 5

    // DefaultAwesomeOscillatorLongPeriod is the default long period for the Awesome Oscillator (AO).
    DefaultAwesomeOscillatorLongPeriod = 34
)
```

<a name="DefaultChaikinOscillatorShortPeriod"></a>

```go
const (
    // DefaultChaikinOscillatorShortPeriod is the default short period for the Chaikin Oscillator.
    DefaultChaikinOscillatorShortPeriod = 3

    // DefaultChaikinOscillatorLongPeriod is the default long period for the Chaikin Oscillator.
    DefaultChaikinOscillatorLongPeriod = 10
)
```

<a name="DefaultConnorsRsiRsiPeriod"></a>

```go
const (
    // DefaultConnorsRsiRsiPeriod is the default RSI period.
    DefaultConnorsRsiRsiPeriod = 3
    // DefaultConnorsRsiStreakRsiPeriod is the default Streak RSI period.
    DefaultConnorsRsiStreakRsiPeriod = 2
    // DefaultConnorsRsiPercentRankPeriod is the default PercentRank period.
    DefaultConnorsRsiPercentRankPeriod = 100
)
```

<a name="DefaultFisherPeriod"></a>

```go
const (
    // DefaultFisherPeriod is the default period for the Fisher Transform.
    DefaultFisherPeriod = 10

    // FisherClamp is the boundary value for clamping.
    FisherClamp = 0.999
)
```

<a name="DefaultIchimokuCloudConversionPeriod"></a>

```go
const (
    // DefaultIchimokuCloudConversionPeriod is the default conversion period for the Ichimoku Cloud.
    DefaultIchimokuCloudConversionPeriod = 9

    // DefaultIchimokuCloudBasePeriod is the default base period for the Ichimoku Cloud.
    DefaultIchimokuCloudBasePeriod = 26

    // DefaultIchimokuCloudLeadingPeriod is the default leading period for the Ichimoku Cloud.
    DefaultIchimokuCloudLeadingPeriod = 52

    // DefaultIchimokuCloudLaggingPeriod is the default lagging period for the Ichimoku Cloud.
    DefaultIchimokuCloudLaggingPeriod = 26
)
```

<a name="DefaultPpoShortPeriod"></a>

```go
const (
    // DefaultPpoShortPeriod is the default short period for the Percentage Price Oscillator.
    DefaultPpoShortPeriod = 12

    // DefaultPpoLongPeriod is the default long period for the Percentage Price Oscillator.
    DefaultPpoLongPeriod = 26

    // DefaultPpoSignalPeriod is the default signal period for the Percentage Price Oscillator.
    DefaultPpoSignalPeriod = 9
)
```

<a name="DefaultPvoShortPeriod"></a>

```go
const (
    // DefaultPvoShortPeriod is the default short period for the Percentage Volume Oscillator.
    DefaultPvoShortPeriod = 12

    // DefaultPvoLongPeriod is the default long period for the Percentage Volume Oscillator.
    DefaultPvoLongPeriod = 26

    // DefaultPvoSignalPeriod is the default signal period for the Percentage Volume Oscillator.
    DefaultPvoSignalPeriod = 9
)
```

<a name="DefaultRviPeriod"></a>

```go
const (
    // DefaultRviPeriod is the default period for the Relative Vigor Index.
    DefaultRviPeriod = 10

    // DefaultRviSignalPeriod is the default signal line period for RVI.
    DefaultRviSignalPeriod = 4

    // RviFirPeriod is the FIR filter period (4 bars).
    RviFirPeriod = 4

    // RviFirSum is the sum of FIR weights (1+2+2+1 = 6).
    RviFirSum = 6
)
```

<a name="DefaultStochasticOscillatorMaxAndMinPeriod"></a>

```go
const (
    // DefaultStochasticOscillatorMaxAndMinPeriod is the default max and min period for the Stochastic Oscillator.
    DefaultStochasticOscillatorMaxAndMinPeriod = 14

    // DefaultStochasticOscillatorPeriod is the default period for the Stochastic Oscillator.
    DefaultStochasticOscillatorPeriod = 3
)
```

<a name="DefaultTdSequentialLookback"></a>

```go
const (
    // DefaultTdSequentialLookback is the default lookback period for comparing closes.
    DefaultTdSequentialLookback = 4

    // DefaultTdSequentialCountdownLookback is the default lookback period for countdown comparison.
    DefaultTdSequentialCountdownLookback = 2

    // DefaultTdSequentialSetupPeriod is the default setup period (9).
    DefaultTdSequentialSetupPeriod = 9

    // DefaultTdSequentialCountdownPeriod is the default countdown period (13).
    DefaultTdSequentialCountdownPeriod = 13
)
```

<a name="DefaultQstickPeriod"></a>

```go
const (
    // DefaultQstickPeriod is the default period for the Qstick SMA.
    DefaultQstickPeriod = 20
)
```

<a name="DefaultRsiPeriod"></a>

```go
const (
    // DefaultRsiPeriod is the default period for the Relative Strength Index (RSI).
    DefaultRsiPeriod = 14
)
```

<a name="DefaultStochasticRsiPeriod"></a>

```go
const (
    // DefaultStochasticRsiPeriod is the default period for the Stochastic Relative Strength Index (RSI).
    DefaultStochasticRsiPeriod = 14
)
```

<a name="DefaultWilliamsRPeriod"></a>

```go
const (
    // DefaultWilliamsRPeriod is the default period for the Williams R.
    DefaultWilliamsRPeriod = 14
)
```

<a name="AwesomeOscillator"></a>
## type [AwesomeOscillator](<https://github.com/cinar/indicator/blob/master/momentum/awesome_oscillator.go#L33-L39>)

AwesomeOscillator represents the configuration parameter for calculating the Awesome Oscillator \(AO\). It gauges market momentum by comparing short\-term price action \(5\-period average\) against long\-term trends \(34\-period average\). Its value around a zero line reflects bullishness above and bearishness below. Crossings of the zero line can signal potential trend reversals. Traders use the AO to confirm existing trends, identify entry/exit points, and understand momentum shifts.

```
Median Price = ((Low + High) / 2).
AO = 5-Period SMA - 34-Period SMA.
```

Example:

```
ao := momentum.AwesomeOscillator[float64]()
values := ao.Compute(lows, highs)
```

```go
type AwesomeOscillator[T helper.Number] struct {
    // ShortSma is the SMA for the short period.
    ShortSma *trend.Sma[T]

    // LongSma is the SMA for the long period.
    LongSma *trend.Sma[T]
}
```

<a name="NewAwesomeOscillator"></a>
### func [NewAwesomeOscillator](<https://github.com/cinar/indicator/blob/master/momentum/awesome_oscillator.go#L42>)

```go
func NewAwesomeOscillator[T helper.Number]() *AwesomeOscillator[T]
```

NewAwesomeOscillator function initializes a new Awesome Oscillator instance.

<a name="AwesomeOscillator[T].Compute"></a>
### func \(\*AwesomeOscillator\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/master/momentum/awesome_oscillator.go#L50>)

```go
func (a *AwesomeOscillator[T]) Compute(highs, lows <-chan T) <-chan T
```

Compute function takes a channel of numbers and computes the AwesomeOscillator.

<a name="AwesomeOscillator[T].IdlePeriod"></a>
### func \(\*AwesomeOscillator\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/master/momentum/awesome_oscillator.go#L71>)

```go
func (a *AwesomeOscillator[T]) IdlePeriod() int
```

IdlePeriod is the initial period that Awesome Oscillator won't yield any results.

<a name="ChaikinOscillator"></a>
## type [ChaikinOscillator](<https://github.com/cinar/indicator/blob/master/momentum/chaikin_oscillator.go#L32-L41>)

ChaikinOscillator represents the configuration parameter for calculating the Chaikin Oscillator. It measures the momentum of the Accumulation/Distribution \(A/D\) using the Moving Average Convergence Divergence \(MACD\) formula. It takes the difference between fast and slow periods EMA of the A/D. Cross above the A/D line indicates bullish.

```
CO = Ema(fastPeriod, AD) - Ema(slowPeriod, AD)
```

Example:

```
co := momentum.ChaikinOscillator[float64]()
values := co.Compute(lows, highs)
```

```go
type ChaikinOscillator[T helper.Number] struct {
    // Ad is the Accumulation/Distribution (A/D) instance.
    Ad  *volume.Ad[T]

    // ShortEma is the SMA for the short period.
    ShortEma *trend.Ema[T]

    // LongEma is the SMA for the long period.
    LongEma *trend.Ema[T]
}
```

<a name="NewChaikinOscillator"></a>
### func [NewChaikinOscillator](<https://github.com/cinar/indicator/blob/master/momentum/chaikin_oscillator.go#L44>)

```go
func NewChaikinOscillator[T helper.Number]() *ChaikinOscillator[T]
```

NewChaikinOscillator function initializes a new Chaikin Oscillator instance.

<a name="ChaikinOscillator[T].Compute"></a>
### func \(\*ChaikinOscillator\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/master/momentum/chaikin_oscillator.go#L53>)

```go
func (c *ChaikinOscillator[T]) Compute(highs, lows, closings, volumes <-chan T) (<-chan T, <-chan T)
```

Compute function takes a channel of numbers and computes the Chaikin Oscillator.

<a name="ChaikinOscillator[T].IdlePeriod"></a>
### func \(\*ChaikinOscillator\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/master/momentum/chaikin_oscillator.go#L71>)

```go
func (c *ChaikinOscillator[T]) IdlePeriod() int
```

IdlePeriod is the initial period that Chaikin Oscillator won't yield any results.

<a name="ConnorsRsi"></a>
## type [ConnorsRsi](<https://github.com/cinar/indicator/blob/master/momentum/connors_rsi.go#L35-L51>)

ConnorsRsi represents the configuration parameters for calculating the Connors RSI. It is a momentum indicator that combines three components: 1. RSI of closing prices 2. RSI of up/down streak length 3. Percentile rank of the rate of change

```
CRSI = (RSI(3) + RSI(Streak, 2) + PercentRank(ROC, 100)) / 3
```

Example:

```
connorsRsi := momentum.NewConnorsRsi[float64]()
result := connorsRsi.Compute(closings)
```

```go
type ConnorsRsi[T helper.Float] struct {
    // RsiPeriod is the period for the RSI on closing prices.
    RsiPeriod int
    // StreakRsiPeriod is the period for the RSI on streak length.
    StreakRsiPeriod int
    // PercentRankPeriod is the period for the PercentRank of ROC.
    PercentRankPeriod int

    // Rsi is the RSI instance for closing prices.
    Rsi *Rsi[T]
    // StreakRsi is the RSI instance for streak length.
    StreakRsi *Rsi[T]
    // Roc is the Rate of Change instance.
    Roc *trend.Roc[T]
    // Streak is the streak calculator instance.
    Streak *Streak[T]
}
```

<a name="NewConnorsRsi"></a>
### func [NewConnorsRsi](<https://github.com/cinar/indicator/blob/master/momentum/connors_rsi.go#L54>)

```go
func NewConnorsRsi[T helper.Float]() *ConnorsRsi[T]
```

NewConnorsRsi function initializes a new Connors RSI instance with the default parameters.

<a name="NewConnorsRsiWithPeriods"></a>
### func [NewConnorsRsiWithPeriods](<https://github.com/cinar/indicator/blob/master/momentum/connors_rsi.go#L63>)

```go
func NewConnorsRsiWithPeriods[T helper.Float](rsiPeriod, streakRsiPeriod, percentRankPeriod int) *ConnorsRsi[T]
```

NewConnorsRsiWithPeriods function initializes a new Connors RSI instance with the given periods.

<a name="ConnorsRsi[T].Compute"></a>
### func \(\*ConnorsRsi\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/master/momentum/connors_rsi.go#L86>)

```go
func (c *ConnorsRsi[T]) Compute(closings <-chan T) <-chan T
```

Compute function takes a channel of closings numbers and computes the Connors RSI.

<a name="ConnorsRsi[T].IdlePeriod"></a>
### func \(\*ConnorsRsi\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/master/momentum/connors_rsi.go#L117>)

```go
func (c *ConnorsRsi[T]) IdlePeriod() int
```

IdlePeriod is the initial period that Connors RSI won't yield any results.

<a name="ConnorsRsi[T].String"></a>
### func \(\*ConnorsRsi\[T\]\) [String](<https://github.com/cinar/indicator/blob/master/momentum/connors_rsi.go#L124>)

```go
func (c *ConnorsRsi[T]) String() string
```

String is the string representation of the Connors RSI.

<a name="Fisher"></a>
## type [Fisher](<https://github.com/cinar/indicator/blob/master/momentum/fisher.go#L38-L47>)

Fisher represents the configuration parameters for calculating the Fisher Transform. The Fisher Transform is a technical indicator that transforms prices into a normal distribution to identify price reversals.

```
x = 2 * ((close - min) / (max - min)) - 1
Fisher = 0.5 * ln((1 + x) / (1 - x))
```

The clamped x value is bounded between \-0.999 and \+0.999 to prevent division by zero or logarithmic infinity errors.

Example:

```
fisher := momentum.NewFisher[float64]()
result := fisher.Compute(closings)
```

```go
type Fisher[T helper.Float] struct {
    // Period is the lookback period for min/max calculation.
    Period int

    // Max is the Moving Max instance.
    Max *trend.MovingMax[T]

    // Min is the Moving Min instance.
    Min *trend.MovingMin[T]
}
```

<a name="NewFisher"></a>
### func [NewFisher](<https://github.com/cinar/indicator/blob/master/momentum/fisher.go#L50>)

```go
func NewFisher[T helper.Float]() *Fisher[T]
```

NewFisher function initializes a new Fisher Transform instance.

<a name="Fisher[T].Compute"></a>
### func \(\*Fisher\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/master/momentum/fisher.go#L59>)

```go
func (f *Fisher[T]) Compute(closings <-chan T) <-chan T
```

Compute function takes a channel of numbers and computes the Fisher Transform.

<a name="Fisher[T].IdlePeriod"></a>
### func \(\*Fisher\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/master/momentum/fisher.go#L105>)

```go
func (f *Fisher[T]) IdlePeriod() int
```

IdlePeriod is the initial period that Fisher Transform won't yield any results.

<a name="Fisher[T].String"></a>
### func \(\*Fisher\[T\]\) [String](<https://github.com/cinar/indicator/blob/master/momentum/fisher.go#L113>)

```go
func (f *Fisher[T]) String() string
```

String is the string representation of the Fisher Transform.

<a name="IchimokuCloud"></a>
## type [IchimokuCloud](<https://github.com/cinar/indicator/blob/master/momentum/ichimoku_cloud.go#L40-L61>)

IchimokuCloud represents the configuration parameter for calculating the Ichimoku Cloud. It is also known as the Ichimoku Kinko Hyo, is a versatile indicator that defines support and resistance, identifies trend direction, gauges momentum, and provides trading signals.

```
Tenkan-sen (Conversion Line) = (9-Period High + 9-Period Low) / 2
Kijun-sen (Base Line) = (26-Period High + 26-Period Low) / 2
Senkou Span A (Leading Span A) = (Conversion Line + Base Line) / 2
Senkou Span B (Leading Span B) = (52-Period High + 52-Period Low) / 2
Chikou Span (Lagging Span) = Closing plotted 26 days in the past.
```

Example:

```
ic := momentum.IchimokuCloud[float64]()
conversionLine, baseLine, leadingSpanA, leasingSpanB, laggingSpan := ic.Compute(highs, lows, closings)
```

```go
type IchimokuCloud[T helper.Number] struct {
    // ConversionMax is the conversion Moving Max instance.
    ConversionMax *trend.MovingMax[T]

    // ConversionMin is the conversion Moving Min instance.
    ConversionMin *trend.MovingMin[T]

    // BaseMax is the base Moving Max instance.
    BaseMax *trend.MovingMax[T]

    // BaseMin is the base Moving Min instance.
    BaseMin *trend.MovingMin[T]

    // LeadingMax is the leading Moving Max instance.
    LeadingMax *trend.MovingMax[T]

    // LeadingMin is the leading Moving Min instance.
    LeadingMin *trend.MovingMin[T]

    // LaggingPeriod is the lagging period.
    LaggingPeriod int
}
```

<a name="NewIchimokuCloud"></a>
### func [NewIchimokuCloud](<https://github.com/cinar/indicator/blob/master/momentum/ichimoku_cloud.go#L64>)

```go
func NewIchimokuCloud[T helper.Number]() *IchimokuCloud[T]
```

NewIchimokuCloud function initializes a new Ichimoku Cloud instance.

<a name="IchimokuCloud[T].Compute"></a>
### func \(\*IchimokuCloud\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/master/momentum/ichimoku_cloud.go#L78>)

```go
func (i *IchimokuCloud[T]) Compute(highs, lows, closings <-chan T) (<-chan T, <-chan T, <-chan T, <-chan T, <-chan T)
```

Compute function takes a channel of numbers and computes the Ichimoku Cloud. Returns conversionLine, baseLine, leadingSpanA, leadingSpanB, laggingSpan

<a name="IchimokuCloud[T].IdlePeriod"></a>
### func \(\*IchimokuCloud\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/master/momentum/ichimoku_cloud.go#L139>)

```go
func (i *IchimokuCloud[T]) IdlePeriod() int
```

IdlePeriod is the initial period that Ichimoku Cloud won't yield any results.

<a name="Ppo"></a>
## type [Ppo](<https://github.com/cinar/indicator/blob/master/momentum/ppo.go#L35-L44>)

Ppo represents the configuration parameter for calculating the Percentage Price Oscillator \(PPO\). It is a momentum oscillator for the price. It is used to indicate the ups and downs based on the price. A breakout is confirmed when PPO is positive.

```
PPO = ((EMA(shortPeriod, prices) - EMA(longPeriod, prices)) / EMA(longPeriod, prices)) * 100
Signal = EMA(9, PPO)
Histogram = PPO - Signal
```

Example:

```
ppo := momentum.Ppo[float64]()
p, s, h := ppo.Compute(closings)
```

```go
type Ppo[T helper.Number] struct {
    // ShortEma is the short EMA instance.
    ShortEma *trend.Ema[T]

    // LongEma is the long EMA instance.
    LongEma *trend.Ema[T]

    // SignalEma is the signal EMA instance.
    SignalEma *trend.Ema[T]
}
```

<a name="NewPpo"></a>
### func [NewPpo](<https://github.com/cinar/indicator/blob/master/momentum/ppo.go#L47>)

```go
func NewPpo[T helper.Number]() *Ppo[T]
```

NewPpo function initializes a new Percentage Price Oscillator instance.

<a name="Ppo[T].Compute"></a>
### func \(\*Ppo\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/master/momentum/ppo.go#L57>)

```go
func (p *Ppo[T]) Compute(closings <-chan T) (<-chan T, <-chan T, <-chan T)
```

Compute function takes a channel of numbers and computes the Percentage Price Oscillator. Returns ppo, signal, histogram.

<a name="Ppo[T].IdlePeriod"></a>
### func \(\*Ppo\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/master/momentum/ppo.go#L100>)

```go
func (p *Ppo[T]) IdlePeriod() int
```

IdlePeriod is the initial period that Percentage Price Oscillator won't yield any results.

<a name="PringsSpecialK"></a>
## type [PringsSpecialK](<https://github.com/cinar/indicator/blob/master/momentum/prings_special_k.go#L12-L38>)

PringsSpecialK implements Martin Pring's Special K momentum indicator. It composes multiple Rate\-of\-Change \(ROC\) series smoothed by Simple Moving Averages \(SMA\) and outputs a weighted sum aligned to the slowest path so all terms are time\-synchronized. See Compute for the exact composition and weights.

```go
type PringsSpecialK[T helper.Float] struct {
    Roc10  *trend.Roc[T]
    Roc15  *trend.Roc[T]
    Roc20  *trend.Roc[T]
    Roc30  *trend.Roc[T]
    Roc40  *trend.Roc[T]
    Roc65  *trend.Roc[T]
    Roc75  *trend.Roc[T]
    Roc100 *trend.Roc[T]
    Roc195 *trend.Roc[T]
    Roc265 *trend.Roc[T]
    Roc390 *trend.Roc[T]
    Roc530 *trend.Roc[T]

    Sma10Roc10   *trend.Sma[T]
    Sma10Roc15   *trend.Sma[T]
    Sma10Roc20   *trend.Sma[T]
    Sma15Roc30   *trend.Sma[T]
    Sma50Roc40   *trend.Sma[T]
    Sma65Roc65   *trend.Sma[T]
    Sma75Roc75   *trend.Sma[T]
    Sma100Roc100 *trend.Sma[T]
    Sma130Roc195 *trend.Sma[T]
    Sma130Roc265 *trend.Sma[T]
    Sma130Roc390 *trend.Sma[T]
    Sma195Roc530 *trend.Sma[T]
}
```

<a name="NewPringsSpecialK"></a>
### func [NewPringsSpecialK](<https://github.com/cinar/indicator/blob/master/momentum/prings_special_k.go#L41>)

```go
func NewPringsSpecialK[T helper.Float]() *PringsSpecialK[T]
```

NewPringsSpecialK function initializes a new Martin Pring's Special K instance.

<a name="PringsSpecialK[T].Compute"></a>
### func \(\*PringsSpecialK\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/master/momentum/prings_special_k.go#L72>)

```go
func (p *PringsSpecialK[T]) Compute(closings <-chan T) <-chan T
```

Compute function takes a channel of numbers and computes the Prings Special K.

<a name="Pvo"></a>
## type [Pvo](<https://github.com/cinar/indicator/blob/master/momentum/pvo.go#L35-L44>)

Pvo represents the configuration parameter for calculating the Percentage Volume Oscillator \(PVO\). It is a momentum oscillator for the price. It is used to indicate the ups and downs based on the price. A breakout is confirmed when PVO is positive.

```
PVO = ((EMA(shortPeriod, prices) - EMA(longPeriod, prices)) / EMA(longPeriod, prices)) * 100
Signal = EMA(9, PVO)
Histogram = PVO - Signal
```

Example:

```
pvo := momentum.Pvo[float64]()
p, s, h := pvo.Compute(volumes)
```

```go
type Pvo[T helper.Number] struct {
    // ShortEma is the short EMA instance.
    ShortEma *trend.Ema[T]

    // LongEma is the long EMA instance.
    LongEma *trend.Ema[T]

    // SignalEma is the signal EMA instance.
    SignalEma *trend.Ema[T]
}
```

<a name="NewPvo"></a>
### func [NewPvo](<https://github.com/cinar/indicator/blob/master/momentum/pvo.go#L47>)

```go
func NewPvo[T helper.Number]() *Pvo[T]
```

NewPvo function initializes a new Percentage Volume Oscillator instance.

<a name="Pvo[T].Compute"></a>
### func \(\*Pvo\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/master/momentum/pvo.go#L57>)

```go
func (p *Pvo[T]) Compute(volumes <-chan T) (<-chan T, <-chan T, <-chan T)
```

Compute function takes a channel of numbers and computes the Percentage Volume Oscillator. Returns pvo, signal, histogram.

<a name="Pvo[T].IdlePeriod"></a>
### func \(\*Pvo\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/master/momentum/pvo.go#L100>)

```go
func (p *Pvo[T]) IdlePeriod() int
```

IdlePeriod is the initial period that Percentage Volume Oscillator won't yield any results.

<a name="Qstick"></a>
## type [Qstick](<https://github.com/cinar/indicator/blob/master/momentum/qstick.go#L33-L35>)

Qstick represents the configuration parameter for calculating the Qstick indicator. Qstick is a momentum indicator used to identify an asset's trend by looking at the SMA of the difference between its closing and opening.

A Qstick above zero indicates increasing buying pressure, while a Qstick below zero indicates increasing selling pressure.

```
QS = SMA(Closings - Openings)
```

Example:

```
qstick := momentum.Qstick[float64]()
qstick.Sma.Period = 50

values := qstick.Compute(openings, closings)
```

```go
type Qstick[T helper.Number] struct {
    Sma *trend.Sma[T]
}
```

<a name="NewQstick"></a>
### func [NewQstick](<https://github.com/cinar/indicator/blob/master/momentum/qstick.go#L38>)

```go
func NewQstick[T helper.Number]() *Qstick[T]
```

NewQstick function initializes a new QStick instance.

<a name="Qstick[T].Compute"></a>
### func \(\*Qstick\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/master/momentum/qstick.go#L49>)

```go
func (q *Qstick[T]) Compute(openings, closings <-chan T) <-chan T
```

Compute function takes a channel of numbers and computes the Qstick.

<a name="Qstick[T].IdlePeriod"></a>
### func \(\*Qstick\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/master/momentum/qstick.go#L57>)

```go
func (q *Qstick[T]) IdlePeriod() int
```

IdlePeriod is the initial period that Qstick won't yield any results.

<a name="Rsi"></a>
## type [Rsi](<https://github.com/cinar/indicator/blob/master/momentum/rsi.go#L27-L30>)

Rsi represents the configuration parameter for calculating the Relative Strength Index \(RSI\). It is a momentum indicator that measures the magnitude of recent price changes to evaluate overbought and oversold conditions.

```
RS = Average Gain / Average Loss
RSI = 100 - (100 / (1 + RS))
```

Example:

```
rsi := momentum.NewRsi[float64]()
result := rsi.Compute(closings)
```

```go
type Rsi[T helper.Number] struct {
    // Rma is the RMA instance.
    Rma *trend.Rma[T]
}
```

<a name="NewRsi"></a>
### func [NewRsi](<https://github.com/cinar/indicator/blob/master/momentum/rsi.go#L33>)

```go
func NewRsi[T helper.Number]() *Rsi[T]
```

NewRsi function initializes a new Relative Strength Index instance with the default parameters.

<a name="NewRsiWithPeriod"></a>
### func [NewRsiWithPeriod](<https://github.com/cinar/indicator/blob/master/momentum/rsi.go#L38>)

```go
func NewRsiWithPeriod[T helper.Number](period int) *Rsi[T]
```

NewRsiWithPeriod function initializes a new Relative Strength Index instance with the given period.

<a name="Rsi[T].Compute"></a>
### func \(\*Rsi\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/master/momentum/rsi.go#L45>)

```go
func (r *Rsi[T]) Compute(closings <-chan T) <-chan T
```

Compute function takes a channel of closings numbers and computes the Relative Strength Index.

<a name="Rsi[T].IdlePeriod"></a>
### func \(\*Rsi\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/master/momentum/rsi.go#L90>)

```go
func (r *Rsi[T]) IdlePeriod() int
```

IdlePeriod is the initial period that Relative Strength Index won't yield any results.

<a name="Rvi"></a>
## type [Rvi](<https://github.com/cinar/indicator/blob/master/momentum/rvi.go#L45-L51>)

Rvi represents the configuration parameters for calculating the Relative Vigor Index \(RVI\). The RVI is a momentum indicator that measures the strength of a trend by comparing close and open prices.

The indicator uses a 4\-bar FIR filter with weights 1\-2\-2\-1:

```
Numerator = Close - Open
Denominator = High - Low
FIR(Numerator) = (1*Num[0] + 2*Num[1] + 2*Num[2] + 1*Num[3]) / 6
FIR(Denominator) = (1*Den[0] + 2*Den[1] + 2*Den[2] + 1*Den[3]) / 6
RVI = SMA(FIR(Numerator), period) / SMA(FIR(Denominator), period)
Signal = SMA(RVI, signalPeriod)
```

Example:

```
rvi := momentum.NewRvi[float64]()
rviResult, signalResult := rvi.Compute(opens, highs, lows, closings)
```

```go
type Rvi[T helper.Float] struct {
    // Period is the lookback period for the RVI.
    Period int

    // SignalPeriod is the signal line period.
    SignalPeriod int
}
```

<a name="NewRvi"></a>
### func [NewRvi](<https://github.com/cinar/indicator/blob/master/momentum/rvi.go#L54>)

```go
func NewRvi[T helper.Float]() *Rvi[T]
```

NewRvi function initializes a new RVI instance.

<a name="Rvi[T].Compute"></a>
### func \(\*Rvi\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/master/momentum/rvi.go#L90>)

```go
func (r *Rvi[T]) Compute(opens, highs, lows, closings <-chan T) (rviResult <-chan T, signalResult <-chan T)
```

Compute function takes channels of OHLC numbers and computes the Relative Vigor Index and its signal line.

<a name="Rvi[T].IdlePeriod"></a>
### func \(\*Rvi\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/master/momentum/rvi.go#L138>)

```go
func (r *Rvi[T]) IdlePeriod() int
```

IdlePeriod is the initial period that RVI won't yield any results.

<a name="Rvi[T].String"></a>
### func \(\*Rvi\[T\]\) [String](<https://github.com/cinar/indicator/blob/master/momentum/rvi.go#L147>)

```go
func (r *Rvi[T]) String() string
```

String is the string representation of the RVI.

<a name="StochasticOscillator"></a>
## type [StochasticOscillator](<https://github.com/cinar/indicator/blob/master/momentum/stochastic_oscillator.go#L31-L40>)

StochasticOscillator represents the configuration parameter for calculating the Stochastic Oscillator. It is a momentum indicator that shows the location of the closing relative to high\-low range over a set number of periods.

```
K = (Closing - Lowest Low) / (Highest High - Lowest Low) * 100
D = 3-Period SMA of K
```

Example:

```
so := momentum.StochasticOscillator[float64]()
k, d := wr.Compute(highs, lows, closings)
```

```go
type StochasticOscillator[T helper.Number] struct {
    // Max is the Moving Max instance.
    Max *trend.MovingMax[T]

    // Min is the Moving Min instance.
    Min *trend.MovingMin[T]

    // Sma is the SMA instance.
    Sma *trend.Sma[T]
}
```

<a name="NewStochasticOscillator"></a>
### func [NewStochasticOscillator](<https://github.com/cinar/indicator/blob/master/momentum/stochastic_oscillator.go#L43>)

```go
func NewStochasticOscillator[T helper.Number]() *StochasticOscillator[T]
```

NewStochasticOscillator function initializes a new Stochastic Oscillator instance.

<a name="StochasticOscillator[T].Compute"></a>
### func \(\*StochasticOscillator\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/master/momentum/stochastic_oscillator.go#L52>)

```go
func (s *StochasticOscillator[T]) Compute(highs, lows, closings <-chan T) (<-chan T, <-chan T)
```

Compute function takes a channel of numbers and computes the Stochastic Oscillator. Returns k and d.

<a name="StochasticOscillator[T].IdlePeriod"></a>
### func \(\*StochasticOscillator\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/master/momentum/stochastic_oscillator.go#L82>)

```go
func (s *StochasticOscillator[T]) IdlePeriod() int
```

IdlePeriod is the initial period that Stochastic Oscillator won't yield any results.

<a name="StochasticRsi"></a>
## type [StochasticRsi](<https://github.com/cinar/indicator/blob/master/momentum/stochastic_rsi.go#L29-L38>)

StochasticRsi represents the configuration parameter for calculating the Stochastic Relative Strength Index \(RSI\). It is a momentum indicator that focuses on the historical performance to evaluate overbought and oversold conditions.

```
RSI - Min(RSI)
Stochastic RSI = -------------------------
                   Max(RSI) - Min(RSI)
```

Example:

```
stochasticRsi := momentum.NewStochasticRsi[float64]()
result := stochasticRsi.Compute(closings)
```

```go
type StochasticRsi[T helper.Number] struct {
    // Rsi is that RSI instance.
    Rsi *Rsi[T]

    // Min is the Moving Min instance.
    Min *trend.MovingMin[T]

    // Max is the Moving Max instance.
    Max *trend.MovingMax[T]
}
```

<a name="NewStochasticRsi"></a>
### func [NewStochasticRsi](<https://github.com/cinar/indicator/blob/master/momentum/stochastic_rsi.go#L41>)

```go
func NewStochasticRsi[T helper.Number]() *StochasticRsi[T]
```

NewStochasticRsi function initializes a new Storchastic RSI instance with the default parameters.

<a name="NewStochasticRsiWithPeriod"></a>
### func [NewStochasticRsiWithPeriod](<https://github.com/cinar/indicator/blob/master/momentum/stochastic_rsi.go#L46>)

```go
func NewStochasticRsiWithPeriod[T helper.Number](period int) *StochasticRsi[T]
```

NewStochasticRsiWithPeriod function initializes a new Stochastic RSI instance with the given period.

<a name="StochasticRsi[T].Compute"></a>
### func \(\*StochasticRsi\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/master/momentum/stochastic_rsi.go#L55>)

```go
func (s *StochasticRsi[T]) Compute(closings <-chan T) <-chan T
```

Compute function takes a channel of closings numbers and computes the Stochastic RSI.

<a name="StochasticRsi[T].IdlePeriod"></a>
### func \(\*StochasticRsi\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/master/momentum/stochastic_rsi.go#L85>)

```go
func (s *StochasticRsi[T]) IdlePeriod() int
```

IdlePeriod is the initial period that Stochasic RSI won't yield any results.

<a name="Streak"></a>
## type [Streak](<https://github.com/cinar/indicator/blob/master/momentum/connors_rsi.go#L130>)

Streak represents the configuration for calculating the up/down streak length. The streak is the number of consecutive days the price has closed up or down.

```go
type Streak[T helper.Float] struct{}
```

<a name="NewStreak"></a>
### func [NewStreak](<https://github.com/cinar/indicator/blob/master/momentum/connors_rsi.go#L133>)

```go
func NewStreak[T helper.Float]() *Streak[T]
```

NewStreak function initializes a new Streak instance.

<a name="Streak[T].Compute"></a>
### func \(\*Streak\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/master/momentum/connors_rsi.go#L139>)

```go
func (s *Streak[T]) Compute(closings <-chan T) <-chan T
```

Compute function takes a channel of closings numbers and computes the streak length. Positive values indicate consecutive up closes, negative values indicate consecutive down closes.

<a name="Streak[T].IdlePeriod"></a>
### func \(\*Streak\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/master/momentum/connors_rsi.go#L176>)

```go
func (s *Streak[T]) IdlePeriod() int
```

IdlePeriod is the initial period that Streak won't yield any results.

<a name="TdSequential"></a>
## type [TdSequential](<https://github.com/cinar/indicator/blob/master/momentum/td_sequential.go#L41-L53>)

TdSequential represents the configuration parameters for calculating the Tom DeMark's TD Sequential indicator. TD Sequential is a momentum indicator that identifies potential trend exhaustion and reversals.

The indicator consists of two phases:

```
TD Setup: Counts 9 consecutive closes higher (sell) or lower (buy) than
the close 4 bars ago.

TD Countdown: After a completed setup, counts 13 closes higher (sell) or
lower (buy) than the close 2 bars ago.
```

Example:

```
td := momentum.NewTdSequential[float64]()
buySetup, sellSetup, buyCountdown, sellCountdown := td.Compute(closings)
```

```go
type TdSequential[T helper.Number] struct {
    // Lookback is the number of bars to look back for comparison in the setup phase.
    Lookback int

    // CountdownLookback is the number of bars to look back for comparison in the countdown phase.
    CountdownLookback int

    // SetupPeriod is the number of consecutive closes required to complete a setup.
    SetupPeriod int

    // CountdownPeriod is the number of closes required to complete a countdown.
    CountdownPeriod int
}
```

<a name="NewTdSequential"></a>
### func [NewTdSequential](<https://github.com/cinar/indicator/blob/master/momentum/td_sequential.go#L56>)

```go
func NewTdSequential[T helper.Number]() *TdSequential[T]
```

NewTdSequential function initializes a new TD Sequential instance with default parameters.

<a name="TdSequential[T].Compute"></a>
### func \(\*TdSequential\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/master/momentum/td_sequential.go#L87>)

```go
func (t *TdSequential[T]) Compute(closings <-chan T) (<-chan T, <-chan T, <-chan T, <-chan T)
```

Compute function takes a channel of numbers and computes the TD Sequential indicator. Returns four channels: buySetup, sellSetup, buyCountdown, sellCountdown.

<a name="TdSequential[T].IdlePeriod"></a>
### func \(\*TdSequential\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/master/momentum/td_sequential.go#L190>)

```go
func (t *TdSequential[T]) IdlePeriod() int
```

IdlePeriod is the initial period that TD Sequential won't yield meaningful results.

<a name="WilliamsR"></a>
## type [WilliamsR](<https://github.com/cinar/indicator/blob/master/momentum/williams_r.go#L29-L35>)

WilliamsR represents the configuration parameter for calculating the Williams %R, or just %R. It is a technical analysis oscillator showing the current closing price in relation to the high and low of the past N days \(for a given N\). It was developed by a publisher and promoter of trading materials, Larry Williams. Its purpose is to tell whether a stock or commodity market is trading near the high or the low, or somewhere in between, of its recent trading range. Buy when \-80 and below. Sell when \-20 and above.

```
WR = (Highest High - Closing) / (Highest High - Lowest Low) * -100.
```

Example:

```
wr := momentum.WilliamsR[float64]()
values := wr.Compute(highs, lows, closings)
```

```go
type WilliamsR[T helper.Number] struct {
    // Max is the Moving Max instance.
    Max *trend.MovingMax[T]

    // Min is the Moving Min instance.
    Min *trend.MovingMin[T]
}
```

<a name="NewWilliamsR"></a>
### func [NewWilliamsR](<https://github.com/cinar/indicator/blob/master/momentum/williams_r.go#L38>)

```go
func NewWilliamsR[T helper.Number]() *WilliamsR[T]
```

NewWilliamsR function initializes a new Williams R instance.

<a name="WilliamsR[T].Compute"></a>
### func \(\*WilliamsR\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/master/momentum/williams_r.go#L46>)

```go
func (w *WilliamsR[T]) Compute(highs, lows, closings <-chan T) <-chan T
```

Compute function takes a channel of numbers and computes the Williams R.

<a name="WilliamsR[T].IdlePeriod"></a>
### func \(\*WilliamsR\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/master/momentum/williams_r.go#L66>)

```go
func (w *WilliamsR[T]) IdlePeriod() int
```

IdlePeriod is the initial period that Williams R won't yield any results.

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
