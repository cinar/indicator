<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# volume

```go
import "github.com/cinar/indicator/v2/volume"
```

Package volume contains the volume indicator functions.

This package belongs to the Indicator project. Indicator is a Golang module that supplies a variety of technical indicators, strategies, and a backtesting framework for analysis.

### License

```
Copyright (c) 2021-2024 Onur Cinar.
The source code is provided under GNU AGPLv3 License.
https://github.com/cinar/indicator
```

### Disclaimer

The information provided on this project is strictly for informational purposes and is not to be construed as advice or solicitation to buy or sell any security.

## Index

- [Constants](<#constants>)
- [type Ad](<#Ad>)
  - [func NewAd\[T helper.Number\]\(\) \*Ad\[T\]](<#NewAd>)
  - [func \(a \*Ad\[T\]\) Compute\(highs, lows, closings, volumes \<\-chan T\) \<\-chan T](<#Ad[T].Compute>)
  - [func \(\*Ad\[T\]\) IdlePeriod\(\) int](<#Ad[T].IdlePeriod>)
- [type Cmf](<#Cmf>)
  - [func NewCmf\[T helper.Number\]\(\) \*Cmf\[T\]](<#NewCmf>)
  - [func NewCmfWithPeriod\[T helper.Number\]\(period int\) \*Cmf\[T\]](<#NewCmfWithPeriod>)
  - [func \(c \*Cmf\[T\]\) Compute\(highs, lows, closings, volumes \<\-chan T\) \<\-chan T](<#Cmf[T].Compute>)
  - [func \(c \*Cmf\[T\]\) IdlePeriod\(\) int](<#Cmf[T].IdlePeriod>)
- [type Emv](<#Emv>)
  - [func NewEmv\[T helper.Number\]\(\) \*Emv\[T\]](<#NewEmv>)
  - [func NewEmvWithPeriod\[T helper.Number\]\(period int\) \*Emv\[T\]](<#NewEmvWithPeriod>)
  - [func \(e \*Emv\[T\]\) Compute\(highs, lows, volumes \<\-chan T\) \<\-chan T](<#Emv[T].Compute>)
  - [func \(e \*Emv\[T\]\) IdlePeriod\(\) int](<#Emv[T].IdlePeriod>)
- [type Fi](<#Fi>)
  - [func NewFi\[T helper.Number\]\(\) \*Fi\[T\]](<#NewFi>)
  - [func NewFiWithPeriod\[T helper.Number\]\(period int\) \*Fi\[T\]](<#NewFiWithPeriod>)
  - [func \(f \*Fi\[T\]\) Compute\(closings, volumes \<\-chan T\) \<\-chan T](<#Fi[T].Compute>)
  - [func \(f \*Fi\[T\]\) IdlePeriod\(\) int](<#Fi[T].IdlePeriod>)
- [type Mfi](<#Mfi>)
  - [func NewMfi\[T helper.Number\]\(\) \*Mfi\[T\]](<#NewMfi>)
  - [func \(m \*Mfi\[T\]\) Compute\(highs, lows, closings, volumes \<\-chan T\) \<\-chan T](<#Mfi[T].Compute>)
  - [func \(m \*Mfi\[T\]\) IdlePeriod\(\) int](<#Mfi[T].IdlePeriod>)
- [type Mfm](<#Mfm>)
  - [func NewMfm\[T helper.Number\]\(\) \*Mfm\[T\]](<#NewMfm>)
  - [func \(\*Mfm\[T\]\) Compute\(highs, lows, closings \<\-chan T\) \<\-chan T](<#Mfm[T].Compute>)
  - [func \(\*Mfm\[T\]\) IdlePeriod\(\) int](<#Mfm[T].IdlePeriod>)
- [type Mfv](<#Mfv>)
  - [func NewMfv\[T helper.Number\]\(\) \*Mfv\[T\]](<#NewMfv>)
  - [func \(m \*Mfv\[T\]\) Compute\(highs, lows, closings, volumes \<\-chan T\) \<\-chan T](<#Mfv[T].Compute>)
  - [func \(\*Mfv\[T\]\) IdlePeriod\(\) int](<#Mfv[T].IdlePeriod>)
- [type Nvi](<#Nvi>)
  - [func NewNvi\[T helper.Number\]\(\) \*Nvi\[T\]](<#NewNvi>)
  - [func \(n \*Nvi\[T\]\) Compute\(closings, volumes \<\-chan T\) \<\-chan T](<#Nvi[T].Compute>)
  - [func \(\*Nvi\[T\]\) IdlePeriod\(\) int](<#Nvi[T].IdlePeriod>)
- [type Obv](<#Obv>)
  - [func NewObv\[T helper.Number\]\(\) \*Obv\[T\]](<#NewObv>)
  - [func \(\*Obv\[T\]\) Compute\(closings, volumes \<\-chan T\) \<\-chan T](<#Obv[T].Compute>)
  - [func \(\*Obv\[T\]\) IdlePeriod\(\) int](<#Obv[T].IdlePeriod>)
- [type Vpt](<#Vpt>)
  - [func NewVpt\[T helper.Number\]\(\) \*Vpt\[T\]](<#NewVpt>)
  - [func \(\*Vpt\[T\]\) Compute\(closings, volumes \<\-chan T\) \<\-chan T](<#Vpt[T].Compute>)
  - [func \(\*Vpt\[T\]\) IdlePeriod\(\) int](<#Vpt[T].IdlePeriod>)
- [type Vwap](<#Vwap>)
  - [func NewVwap\[T helper.Number\]\(\) \*Vwap\[T\]](<#NewVwap>)
  - [func NewVwapWithPeriod\[T helper.Number\]\(period int\) \*Vwap\[T\]](<#NewVwapWithPeriod>)
  - [func \(v \*Vwap\[T\]\) Compute\(closings, volumes \<\-chan T\) \<\-chan T](<#Vwap[T].Compute>)
  - [func \(v \*Vwap\[T\]\) IdlePeriod\(\) int](<#Vwap[T].IdlePeriod>)


## Constants

<a name="DefaultCmfPeriod"></a>

```go
const (
    // DefaultCmfPeriod is the default period of CMF.
    DefaultCmfPeriod = 20
)
```

<a name="DefaultEmvPeriod"></a>

```go
const (
    // DefaultEmvPeriod is the default period for the EMV.
    DefaultEmvPeriod = 14
)
```

<a name="DefaultFiPeriod"></a>

```go
const (
    // DefaultFiPeriod is the default period for the FI.
    DefaultFiPeriod = 13
)
```

<a name="DefaultMfiPeriod"></a>

```go
const (
    // DefaultMfiPeriod is the default period of the MFI.
    DefaultMfiPeriod = 14
)
```

<a name="DefaultNviInitial"></a>

```go
const (
    // DefaultNviInitial is the default initial for the NVI.
    DefaultNviInitial = 1000
)
```

<a name="DefaultVwapPeriod"></a>

```go
const (
    // DefaultVwapPeriod is the default period for the VWAP.
    DefaultVwapPeriod = 14
)
```

<a name="Ad"></a>
## type [Ad](<https://github.com/cinar/indicator/blob/v2/volume/ad.go#L20-L23>)

Ad holds configuration parameters for calculating Accumulation/Distribution \(A/D\). It is a cumulative indicator that uses volume and price to assess whether an asset is being accumulated or distributed.

```
MFM = ((Closing - Low) - (High - Closing)) / (High - Low)
MFV = MFM * Period Volume
AD = Previous AD + CMFV
```

Example:

```
ad := volume.NewAd[float64]()
result := ad.Compute(highs, lows, closings, volumes)
```

```go
type Ad[T helper.Number] struct {
    // Mfv is the MFV instance.
    Mfv *Mfv[T]
}
```

<a name="NewAd"></a>
### func [NewAd](<https://github.com/cinar/indicator/blob/v2/volume/ad.go#L26>)

```go
func NewAd[T helper.Number]() *Ad[T]
```

NewAd function initializes a new A/D instance with the default parameters.

<a name="Ad[T].Compute"></a>
### func \(\*Ad\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/v2/volume/ad.go#L33>)

```go
func (a *Ad[T]) Compute(highs, lows, closings, volumes <-chan T) <-chan T
```

Compute function takes a channel of numbers and computes the A/D.

<a name="Ad[T].IdlePeriod"></a>
### func \(\*Ad\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/v2/volume/ad.go#L45>)

```go
func (*Ad[T]) IdlePeriod() int
```

IdlePeriod is the initial period that A/D won't yield any results.

<a name="Cmf"></a>
## type [Cmf](<https://github.com/cinar/indicator/blob/v2/volume/cmf.go#L28-L34>)

Cmf holds configuration parameters for calculating the Chaikin Money Flow \(CMF\). It measures the amount of money flow volume over a given period.

```
MFM = ((Closing - Low) - (High - Closing)) / (High - Low)
MFV = MFM * Volume
CMF = Sum(20, Money Flow Volume) / Sum(20, Volume)
```

Example:

```
cmf := volume.NewCmf[float64]()
result := cmf.Compute(highs, lows, closings, volumes)
```

```go
type Cmf[T helper.Number] struct {
    // Mfv is the MFV instance.
    Mfv *Mfv[T]

    // Sum is the Moving Sum instance.
    Sum *trend.MovingSum[T]
}
```

<a name="NewCmf"></a>
### func [NewCmf](<https://github.com/cinar/indicator/blob/v2/volume/cmf.go#L37>)

```go
func NewCmf[T helper.Number]() *Cmf[T]
```

NewCmf function initializes a new CMF instance with the default parameters.

<a name="NewCmfWithPeriod"></a>
### func [NewCmfWithPeriod](<https://github.com/cinar/indicator/blob/v2/volume/cmf.go#L42>)

```go
func NewCmfWithPeriod[T helper.Number](period int) *Cmf[T]
```

NewCmfWithPeriod function initializes a new CMF instance with the given period.

<a name="Cmf[T].Compute"></a>
### func \(\*Cmf\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/v2/volume/cmf.go#L50>)

```go
func (c *Cmf[T]) Compute(highs, lows, closings, volumes <-chan T) <-chan T
```

Compute function takes a channel of numbers and computes the CMF.

<a name="Cmf[T].IdlePeriod"></a>
### func \(\*Cmf\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/v2/volume/cmf.go#L65>)

```go
func (c *Cmf[T]) IdlePeriod() int
```

IdlePeriod is the initial period that MFV won't yield any results.

<a name="Emv"></a>
## type [Emv](<https://github.com/cinar/indicator/blob/v2/volume/emv.go#L29-L32>)

Emv holds configuration parameters for calculating the Ease of Movement \(EMV\). It is a volume based oscillator measuring the ease of price movement.

```
Distance Moved = ((High + Low) / 2) - ((Priod High + Prior Low) /2)
Box Ratio = ((Volume / 100000000) / (High - Low))
EMV(1) = Distance Moved / Box Ratio
EMV(14) = SMA(14, EMV(1))
```

Example:

```
emv := volume.NewEmv[float64]()
result := emv.Compute(highs, lows, volumes)
```

```go
type Emv[T helper.Number] struct {
    // Sma is the SMA instance.
    Sma *trend.Sma[T]
}
```

<a name="NewEmv"></a>
### func [NewEmv](<https://github.com/cinar/indicator/blob/v2/volume/emv.go#L35>)

```go
func NewEmv[T helper.Number]() *Emv[T]
```

NewEmv function initializes a new EMV instance with the default parameters.

<a name="NewEmvWithPeriod"></a>
### func [NewEmvWithPeriod](<https://github.com/cinar/indicator/blob/v2/volume/emv.go#L40>)

```go
func NewEmvWithPeriod[T helper.Number](period int) *Emv[T]
```

NewEmvWithPeriod function initializes a new EMV instance with the given period.

<a name="Emv[T].Compute"></a>
### func \(\*Emv\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/v2/volume/emv.go#L47>)

```go
func (e *Emv[T]) Compute(highs, lows, volumes <-chan T) <-chan T
```

Compute function takes a channel of numbers and computes the EMV.

<a name="Emv[T].IdlePeriod"></a>
### func \(\*Emv\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/v2/volume/emv.go#L88>)

```go
func (e *Emv[T]) IdlePeriod() int
```

IdlePeriod is the initial period that EMV won't yield any results.

<a name="Fi"></a>
## type [Fi](<https://github.com/cinar/indicator/blob/v2/volume/fi.go#L26-L29>)

Fi holds configuration parameters for calculating the Force Index \(FI\). It uses the closing price and the volume to assess the power behind a move and identify turning points.

```
FI = EMA(period, (Current - Previous) * Volume)
```

Example:

```
fi := volume.NewFi[float64]()
result := fi.Compute(closings, volumes)
```

```go
type Fi[T helper.Number] struct {
    // Ema is the EMA instance.
    Ema *trend.Ema[T]
}
```

<a name="NewFi"></a>
### func [NewFi](<https://github.com/cinar/indicator/blob/v2/volume/fi.go#L32>)

```go
func NewFi[T helper.Number]() *Fi[T]
```

NewFi function initializes a new FI instance with the default parameters.

<a name="NewFiWithPeriod"></a>
### func [NewFiWithPeriod](<https://github.com/cinar/indicator/blob/v2/volume/fi.go#L37>)

```go
func NewFiWithPeriod[T helper.Number](period int) *Fi[T]
```

NewFiWithPeriod function initializes a new FI instance with the given period.

<a name="Fi[T].Compute"></a>
### func \(\*Fi\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/v2/volume/fi.go#L44>)

```go
func (f *Fi[T]) Compute(closings, volumes <-chan T) <-chan T
```

Compute function takes a channel of numbers and computes the FI.

<a name="Fi[T].IdlePeriod"></a>
### func \(\*Fi\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/v2/volume/fi.go#L54>)

```go
func (f *Fi[T]) IdlePeriod() int
```

IdlePeriod is the initial period that FI won't yield any results.

<a name="Mfi"></a>
## type [Mfi](<https://github.com/cinar/indicator/blob/v2/volume/mfi.go#L29-L35>)

Mfi holds configuration parameters for calculating the Money Flow Index \(MFI\). It analyzes both the closing price and the volume to measure to identify overbought and oversold states. It is similar to the Relative Strength Index \(RSI\), but it also uses the volume.

```
Raw Money Flow = Typical Price * Volume
Money Ratio = Positive Money Flow / Negative Money Flow
Money Flow Index = 100 - (100 / (1 + Money Ratio))
```

Example:

```
mfi := volume.NewMfi[float64]()
result := mfi.Compute(highs, lows, closings, volumes)
```

```go
type Mfi[T helper.Number] struct {
    // TypicalPrice is the Typical Price instance.
    TypicalPrice *trend.TypicalPrice[T]

    // Sum is the Moving Sum instance.
    Sum *trend.MovingSum[T]
}
```

<a name="NewMfi"></a>
### func [NewMfi](<https://github.com/cinar/indicator/blob/v2/volume/mfi.go#L38>)

```go
func NewMfi[T helper.Number]() *Mfi[T]
```

NewMfi function initializes a new MFI instance with the default parameters.

<a name="Mfi[T].Compute"></a>
### func \(\*Mfi\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/v2/volume/mfi.go#L46>)

```go
func (m *Mfi[T]) Compute(highs, lows, closings, volumes <-chan T) <-chan T
```

Compute function takes a channel of numbers and computes the MFI.

<a name="Mfi[T].IdlePeriod"></a>
### func \(\*Mfi\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/v2/volume/mfi.go#L96>)

```go
func (m *Mfi[T]) IdlePeriod() int
```

IdlePeriod is the initial period that MFI won't yield any results.

<a name="Mfm"></a>
## type [Mfm](<https://github.com/cinar/indicator/blob/v2/volume/mfm.go#L23>)

Mfm holds configuration parameters for calculating the Money Flow Multiplier \(MFM\), which adjusts volume based on the closing price's position within the high\-low range:

```
MFM = ((Closing - Low) - (High - Closing)) / (High - Low)
```

\- Positive MFM: Close in upper half of range, indicating buying pressure. \- Negative MFM: Close in lower half of range, indicating selling pressure. \- MFM of 1: Close equals high, strongest buying pressure. \- MFM of \-1: Close equals low, strongest selling pressure.

Example:

```
mfm := volume.NewMfm[float64]()
result := mfm.Compute(highs, lows, closings)
```

```go
type Mfm[T helper.Number] struct{}
```

<a name="NewMfm"></a>
### func [NewMfm](<https://github.com/cinar/indicator/blob/v2/volume/mfm.go#L26>)

```go
func NewMfm[T helper.Number]() *Mfm[T]
```

NewMfm function initializes a new MFM instance with the default parameters.

<a name="Mfm[T].Compute"></a>
### func \(\*Mfm\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/v2/volume/mfm.go#L31>)

```go
func (*Mfm[T]) Compute(highs, lows, closings <-chan T) <-chan T
```

Compute function takes a channel of numbers and computes the MFM.

<a name="Mfm[T].IdlePeriod"></a>
### func \(\*Mfm\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/v2/volume/mfm.go#L46>)

```go
func (*Mfm[T]) IdlePeriod() int
```

IdlePeriod is the initial period that MFM won't yield any results.

<a name="Mfv"></a>
## type [Mfv](<https://github.com/cinar/indicator/blob/v2/volume/mfv.go#L21-L24>)

Mfv holds configuration parameters for calculating Money Flow Volume \(MFV\), a volume\-based indicator that incorporates the Money Flow Multiplier \(MFM\) to gauge the intensity of buying and selling pressure. MFV reflects the cumulative volume adjusted by MFM, with higher values indicating stronger buying pressure and lower values suggesting selling dominance. MFV highlights periods of significant volume\-driven price action, offering insights into potential trend strength and reversals.

```
MFV = MFM * Volume
```

Example:

```
mfv := volume.NewMfv[float64]()
result := mfv.Compute(highs, lows, closings, volumes)
```

```go
type Mfv[T helper.Number] struct {
    // Mfm is the MFM instance.
    Mfm *Mfm[T]
}
```

<a name="NewMfv"></a>
### func [NewMfv](<https://github.com/cinar/indicator/blob/v2/volume/mfv.go#L27>)

```go
func NewMfv[T helper.Number]() *Mfv[T]
```

NewMfv function initializes a new MFV instance with the default parameters.

<a name="Mfv[T].Compute"></a>
### func \(\*Mfv\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/v2/volume/mfv.go#L34>)

```go
func (m *Mfv[T]) Compute(highs, lows, closings, volumes <-chan T) <-chan T
```

Compute function takes a channel of numbers and computes the MFV.

<a name="Mfv[T].IdlePeriod"></a>
### func \(\*Mfv\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/v2/volume/mfv.go#L42>)

```go
func (*Mfv[T]) IdlePeriod() int
```

IdlePeriod is the initial period that MFV won't yield any results.

<a name="Nvi"></a>
## type [Nvi](<https://github.com/cinar/indicator/blob/v2/volume/nvi.go#L31-L34>)

Nvi holds configuration parameters for calculating the Negative Volume Index \(NVI\). It is a cumulative indicator using the change in volume to decide when the smart money is active.

If Volume is greather than Previous Volume:

```
NVI = Previous NVI
```

Otherwise:

```
NVI = Previous NVI + (((Closing - Previous Closing) / Previous Closing) * Previous NVI)
```

Example:

```
nvi := volume.NewNvi[float64]()
result := nvi.Compute(closings, volumes)
```

```go
type Nvi[T helper.Number] struct {
    // Initial is the initial NVI value.
    Initial T
}
```

<a name="NewNvi"></a>
### func [NewNvi](<https://github.com/cinar/indicator/blob/v2/volume/nvi.go#L37>)

```go
func NewNvi[T helper.Number]() *Nvi[T]
```

NewNvi function initializes a new NVI instance with the default parameters.

<a name="Nvi[T].Compute"></a>
### func \(\*Nvi\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/v2/volume/nvi.go#L46>)

```go
func (n *Nvi[T]) Compute(closings, volumes <-chan T) <-chan T
```

Compute function takes a channel of numbers and computes the NVI.

<a name="Nvi[T].IdlePeriod"></a>
### func \(\*Nvi\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/v2/volume/nvi.go#L69>)

```go
func (*Nvi[T]) IdlePeriod() int
```

IdlePeriod is the initial period that NVI won't yield any results.

<a name="Obv"></a>
## type [Obv](<https://github.com/cinar/indicator/blob/v2/volume/obv.go#L21>)

Obv holds configuration parameters for calculating the On\-Balance Volume \(OBV\). It is a technical trading momentum indicator that uses volume flow to predict changes in asset price.

```
Foreach Closing:
	If Closing[i] > Closing[i-1], OBV[i] = OBV[i-1] + Volume[i]
	If Closing[i] = Closing[i-1], OBV[i] = OBV[i-1]
	If Closing[i] < Closing[i-1], OBV[i] = OBV[i-1] - Volume[i]
```

Example:

```
obv := volume.NewObv[float64]()
result := obv.Compute(closings, volumes)
```

```go
type Obv[T helper.Number] struct{}
```

<a name="NewObv"></a>
### func [NewObv](<https://github.com/cinar/indicator/blob/v2/volume/obv.go#L24>)

```go
func NewObv[T helper.Number]() *Obv[T]
```

NewObv function initializes a new OBV instance with the default parameters.

<a name="Obv[T].Compute"></a>
### func \(\*Obv\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/v2/volume/obv.go#L29>)

```go
func (*Obv[T]) Compute(closings, volumes <-chan T) <-chan T
```

Compute function takes a channel of numbers and computes the OBV.

<a name="Obv[T].IdlePeriod"></a>
### func \(\*Obv\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/v2/volume/obv.go#L47>)

```go
func (*Obv[T]) IdlePeriod() int
```

IdlePeriod is the initial period that OBV won't yield any results.

<a name="Vpt"></a>
## type [Vpt](<https://github.com/cinar/indicator/blob/v2/volume/vpt.go#L20>)

Vpt holds configuration parameters for calculating the Volume Price Trend \(VPT\). It provides a correlation between the volume and the price.

```
VPT = Previous VPT + (Volume * (Current Closing - Previous Closing) / Previous Closing)
```

Example:

```
vpt := volume.NewVpt[float64]()
result := vpt.Compute(closings, volumes)
```

```go
type Vpt[T helper.Number] struct{}
```

<a name="NewVpt"></a>
### func [NewVpt](<https://github.com/cinar/indicator/blob/v2/volume/vpt.go#L23>)

```go
func NewVpt[T helper.Number]() *Vpt[T]
```

NewVpt function initializes a new VPT instance with the default parameters.

<a name="Vpt[T].Compute"></a>
### func \(\*Vpt\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/v2/volume/vpt.go#L28>)

```go
func (*Vpt[T]) Compute(closings, volumes <-chan T) <-chan T
```

Compute function takes a channel of numbers and computes the VPT.

<a name="Vpt[T].IdlePeriod"></a>
### func \(\*Vpt\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/v2/volume/vpt.go#L40>)

```go
func (*Vpt[T]) IdlePeriod() int
```

IdlePeriod is the initial period that VPT won't yield any results.

<a name="Vwap"></a>
## type [Vwap](<https://github.com/cinar/indicator/blob/v2/volume/vwap.go#L26-L29>)

Vwap holds configuration parameters for calculating the Volume Weighted Average Price \(VWAP\). It provides the average price the asset has traded.

```
VWAP = Sum(Closing * Volume) / Sum(Volume)
```

Example:

```
vwap := volume.NewVwap[float64]()
result := vwap.Compute(closings, volumes)
```

```go
type Vwap[T helper.Number] struct {
    // Sum is the Moving Sum instance.
    Sum *trend.MovingSum[T]
}
```

<a name="NewVwap"></a>
### func [NewVwap](<https://github.com/cinar/indicator/blob/v2/volume/vwap.go#L32>)

```go
func NewVwap[T helper.Number]() *Vwap[T]
```

NewVwap function initializes a new VWAP instance with the default parameters.

<a name="NewVwapWithPeriod"></a>
### func [NewVwapWithPeriod](<https://github.com/cinar/indicator/blob/v2/volume/vwap.go#L37>)

```go
func NewVwapWithPeriod[T helper.Number](period int) *Vwap[T]
```

NewVwapWithPeriod function initializes a new VWAP instance with the given period.

<a name="Vwap[T].Compute"></a>
### func \(\*Vwap\[T\]\) [Compute](<https://github.com/cinar/indicator/blob/v2/volume/vwap.go#L44>)

```go
func (v *Vwap[T]) Compute(closings, volumes <-chan T) <-chan T
```

Compute function takes a channel of numbers and computes the VWAP.

<a name="Vwap[T].IdlePeriod"></a>
### func \(\*Vwap\[T\]\) [IdlePeriod](<https://github.com/cinar/indicator/blob/v2/volume/vwap.go#L61>)

```go
func (v *Vwap[T]) IdlePeriod() int
```

IdlePeriod is the initial period that VWAP won't yield any results.

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
